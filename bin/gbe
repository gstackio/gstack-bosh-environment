#!/usr/bin/env bash

BASE_DIR=$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")

# White-labeling settings
SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")
project_name=GBE
project_desc="Gstack BOSH Environment"

if ! echo "$PATH" | tr : '\n' | grep -q "^$BASE_DIR/bin$"; then
    # update PATH is not already done by direnv
    PATH=$BASE_DIR/bin:$PATH
fi

source "$BASE_DIR/lib/colors.inc.bash"

function pushd() {
    command pushd "$@" > /dev/null
}

function popd() {
    command popd "$@" > /dev/null
}

function fatal() {
    echo "$@" >&2
    exit 1
}

function platform() {
    local system
    # shellcheck disable=SC2018,SC2019
    system=$(uname -s | tr A-Z a-z)
    if [[ $system == darwin || $system == linux ]]; then
        echo "$system"
    else
        fatal "ERROR: unsupported platform: '$system'. Aborting."
    fi
}

function assert_utilities() {
    local utilities=()

    while # NOTE: emulating do-while, see <https://stackoverflow.com/a/27761760>
        utilities+=("$1"); shift
        [ $# -gt 1 ]
    do :; done
    local reason=$1; shift # last argument

    for utility in "${utilities[@]}"; do
        if ! which "$utility" > /dev/null; then
            fatal "ERROR: $project_name requires '$utility'${reason:+" $reason"}." \
                "Please install it first. Aborting."
        fi
    done
}

function env_usage() {
    local b=$BOLD
    local u=$UNDERLINE
    local rst=$RESET
    local bash_usage="source /dev/stdin <<<\"\$(./bin/$SCRIPT_NAME env)\""
    local zsh_usage="source <\"\$(./bin/$SCRIPT_NAME env)\""
    echo
    local shell_name=$(basename "$SHELL" | tr '[:upper:]' '[:lower:]')
    case $shell_name in
        bash|sh)    usage="$b${u}$bash_usage$rst" ;;
        zsh)        usage="$b${u}$zsh_usage$rst" ;;
        *)          usage="$b${u}$zsh_usage$rst or $b${u}$bash_usage$rst"
    esac
    echo "# Usage: run $usage in your $shell_name shell."
    echo
    echo "# Hint: see the actual environment variables exports" \
        "with $b${u}$SCRIPT_NAME env | cat$rst"
    echo
}

function env_exports() {
    if [ -t 1 ]; then
        # When running in a terminal
        env_usage
        return
    fi

    echo "export PATH=$PATH"

    local env_creds=$BASE_DIR/state/base-env/env-creds.yml
    if [[ ! -f $env_creds ]]; then
        return
    fi

    function get_var() {
        local path=$1
        bosh int "$env_creds" --path "$path"
    }

    echo "export BOSH_CA_CERT=\"$(get_var /default_ca/ca)\""
    echo "export BOSH_CLIENT=admin"
    echo "export BOSH_CLIENT_SECRET=$(get_var /admin_password)"
    echo "export BOSH_GW_PRIVATE_KEY=\"$BASE_DIR/state/base-env/jumpbox.key\""
}

function setup_bbl() {
    local bbl_version=$1

    if which bbl > /dev/null 2>&1; then
        local existing_bbl_version
        existing_bbl_version=$(bbl --version | head -n 1 | cut -d' ' -f2)
        if [[ $existing_bbl_version =~ ^3\.2\. ]]; then
            return 0
        fi
    fi

    local bbl_bin=$BASE_DIR/bin/bbl
    if [ -f "$bbl_bin" ]; then
        return 0
    fi

    assert_utilities curl "to install bosh-bootloader"

    local bbl_repo=https://github.com/cloudfoundry/bosh-bootloader
    local linux_bin=bbl-${bbl_version}_linux_x86-64
    local darwin_bin=bbl-${bbl_version}_osx

    echo -e "\n${BLUE}Installing ${BOLD}bosh-bootloader CLI$RESET $bbl_version as: $bbl_bin\n"
    local url
    case $(platform) in
        darwin) url=$bbl_repo/releases/download/$bbl_version/$darwin_bin;;
        linux)  url=$bbl_repo/releases/download/$bbl_version/$linux_bin;;
    esac

    curl -sL -o "$bbl_bin" "$url"
    chmod +x "$bbl_bin"
}

function setup_terraform() {
    local tf_version=$1

    if which terraform > /dev/null 2>&1; then
        local existing_tf_version
        existing_tf_version=$(terraform --version | head -n 1 | cut -d' ' -f2)
        if [[ $existing_tf_version =~ ^v0\.9\. ]]; then
            return 0
        fi
    fi

    local tf_bin=$BASE_DIR/bin/terraform
    if [ -f "$tf_bin" ]; then
        return 0
    fi

    assert_utilities curl unzip "to install terraform"

    local base_url=https://releases.hashicorp.com/terraform

    echo -e "${BLUE}Installing ${BOLD}terraform CLI$RESET v$tf_version as: $tf_bin"
    local url
    url=$base_url/$tf_version/terraform_${tf_version}_$(platform)_amd64.zip

    local temp_dir
    temp_dir=$(mktemp -d)
    pushd "$temp_dir"
        curl -sL -o tf.zip "$url"
        unzip tf.zip
        rm tf.zip
        mv terraform "$tf_bin"
        chmod +x "$tf_bin"
    popd
    rm -rf "$temp_dir"
}

function setup_bosh_cli() {
    local bosh_cli_version=$1

    if which bosh > /dev/null 2>&1; then
        local existing_bosh_cli_version
        existing_bosh_cli_version=$(bosh --version | head -n 1 | cut -d' ' -f2 | cut -d- -f1)
        if [[ $existing_bosh_cli_version =~ ^2\.0\. ]]; then
            return 0
        fi
    fi

    local bosh_cli_bin=$BASE_DIR/bin/bosh
    if [ -f "$bosh_cli_bin" ]; then
        return 0
    fi

    assert_utilities curl "to install the Bosh CLI"

    echo -e "${BLUE}Installing ${BOLD}Bosh CLI$RESET v$bosh_cli_version as: $bosh_cli_bin"
    curl -sL "https://s3.amazonaws.com/bosh-cli-artifacts/bosh-cli-${bosh_cli_version}-$(platform)-amd64" \
        -o "$bosh_cli_bin"
    chmod +x "$bosh_cli_bin"
}

function setup_dnscontrol() {
    local dnscontrol_version=$1

    if which dnscontrol > /dev/null 2>&1; then
        return 0
    fi

    local dnscontrol_bin=$BASE_DIR/bin/dnscontrol
    if [ -f "$dnscontrol_bin" ]; then
        return 0
    fi

    assert_utilities curl "to install the DNSControl CLI"

    echo -e "${BLUE}Installing ${BOLD}DNSControl CLI$RESET v$dnscontrol_version as: $dnscontrol_bin"

    local system=$(platform)
    local suffix=$(tr '[:lower:]' '[:upper:]' <<< ${system:0:1})${system:1}
    curl -sL "https://github.com/StackExchange/dnscontrol/releases/download/v$dnscontrol_version/dnscontrol-$suffix" \
        -o "$dnscontrol_bin"
    chmod +x "$dnscontrol_bin"
}

function setup_gcp() {
    local service_account_name=$1
    local project_id=$2

    local service_account_key=$BASE_DIR/base-env/conf/gcp-service-account.key.json
    if [ -f "$service_account_key" ]; then
        echo -e "INFO: the 'gcp-service-account.key.json' credentials file" \
            "already exists in directory '$BASE_DIR/base-env/conf/'. ${BLUE}Skipping${RESET}."
        return 0
    fi

    assert_utilities gcloud "to setup GCP credentials"

    echo -e "${BLUE}Setting ${BOLD}GCP credentials$RESET" \
        "for service account '$service_account_name' and project '$project_id'"

    local had_dash_e
    had_dash_e=$(echo $- | tr -Cd e)
    set -e
    gcloud iam service-accounts create "$service_account_name"
    gcloud iam service-accounts keys create \
        --iam-account="${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        "$service_account_key"
    chmod 600 "$service_account_key"
    gcloud projects add-iam-policy-binding "$project_id" \
        --member="serviceAccount:${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        --role='roles/editor'
    if [ -z "$had_dash_e" ]; then
        set +e
    fi

    local temp_file=$(mktemp)
    sed -e "s/^project_id:.*$/project_id: $project_id/" "$BASE_DIR/base-env/conf/env-infra-vars.yml" > "$temp_file"
    cp "$temp_file" "$BASE_DIR/base-env/conf/env-infra-vars.yml"
    rm "$temp_file"

    echo -e "$GREEN${BOLD}OK$RESET"
}

function usage() {
    echo "$project_name ($project_desc) CLI"
    echo "  $BOLD${MAGENTA}SETUP:$RESET"
    echo "  env         Sourceable envrionment variables for CLI clients"
    echo "  bbl         Installs locally the supported version of Bosh-Bootloader CLI"
    echo "  terraform   Installs locally the supported version of Terraform CLI"
    echo "  bosh        Installs locally the supported version of Bosh CLI"
    echo "  dnscontrol  Installs locally the supported version of DNSControl CLI"
    echo "  gcp         Configures the Google Cloud credentials"
    echo "  firewall    Configures the Google Cloud firewall rules"
    echo
    echo "  $BOLD${MAGENTA}BOSH ENVIRONMENT:$RESET"
    echo "  up          Creates the Bosh environment VM with 'bosh create-env'"
    echo "  down        Deletes the Bosh environment VM with 'bosh delete-env'"
    echo "  ip          Outputs the main exernal IP address of the environment"
    echo "  ssh         Logs into the Bosh environment VM with SSH"
    echo
    echo "  $BOLD${MAGENTA}MANAGED DEPLOYMENTS:$RESET"
    echo "  update      Updates the cloud config or the runtime config"
    echo "  converge    Converges one or all Bosh deployments towards their desired states"
    echo "  recreate    Recreates one or all Bosh deployments towards their desired states"
    echo "  delete      Deletes one or all Bosh deployments"
    echo
    echo "  $BOLD${MAGENTA}COMPILED RELEASES:$RESET"
    echo "  export      Popoulate the local cache with all compiled releases"
    echo "  import      Import all compiled releases from the cache to the Bosh server"
    echo "  cleanup     Delete stale compiled releases from the cache"
}

function gcp_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}gcp$noul  <service-account-name>  <project-id>"
    echo
    echo "    <service-account-name>   A name for the service account to be created"
    echo "    <project-id>             The identifier of your GCP project, like 'alpha-sandbox-717101'"
    echo
    echo "Sets the necessary GCP credentials for $project_name:"
    echo "    1. Create the designated service account in GCP."
    echo "    2. Create a service account key in 'conf/gcp-service-account.key.json'."
    echo "    3. Grant to the service account an 'editor' role on the project."
    echo
}

function update_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}update$noul  cloud-config    [-n]"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}update$noul  runtime-config  [-n]"
    echo
    echo "Updates the cloud config or the runtime config in BOSH server."
    echo
    echo "    -n"
    echo "        Don't ask for user input"
    echo
    echo "See also:"
    echo "  ${ul}https://bosh.io/docs/cloud-config.html$noul"
    echo "  ${ul}https://bosh.io/docs/runtime-config.html$noul"
    echo
}

function converge_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}converge$noul  [<deployment-name>]  [-n]"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}converge$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to converge."
    echo
    echo "Converges one or all deployments towards their desired states,"
    echo "or converge the BOSH environment if no deployment is specified."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any user"
    echo "input. Both cloud config and runtime config will be updated,"
    echo "and all deployments will be converged."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function recreate_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}recreate$noul  <deployment-name>  [-n]"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}recreate$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to recreate."
    echo
    echo "Recreates one or all deployments towards their desired states."
    echo "This command is supposed to recreate deployments that were"
    echo "previously deployed with no errors."
    echo "When specifying ${b}all$rst, the recreation will not ask for any"
    echo "user input."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function delete_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}delete$noul  [<deployment-name>]  [-n]"
    echo "  ${ul}$SCRIPT_NAME$noul  ${ul}delete$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to delete."
    echo
    echo "Deletes one or all deployments. Persistent disks will typically"
    echo "be kept as orphaned disks for 5 days, but it's hard to rebuild"
    echo "any deployment with those, so this ${b}delete$rst operation is"
    echo "VERY DESTRUCTIVE."
    echo
    echo "When destroying ${b}all$rst deployments, the deletion will not ask"
    echo "for any user input."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input. NOT RECOMMENDED."
    echo
}

function source_env() { # shim
    local rel_dir=$1

    pushd "$rel_dir"
    if [ -f .envrc ]; then
        source .envrc
    fi
    popd
}

function bbl_invoke() {
    bbl --state-dir "$BASE_DIR/state/base-env" "$@"
}

function setup_firewall() {
    assert_utilities gcloud "to update firewall rules"

    local fw_rule_name
    fw_rule_name=$(bbl_invoke env-id)-bosh-open

    local allowed=icmp
    # Note: the 'gcloud' CLI v180.0.0 doesn't support the shorter syntax with
    #       semicolons, like "icmp; tcp:22,6868,25555". So we revert to the
    #       more verbose syntax here, e.g. "icmp,tcp:22,tcp:6868,tcp:25555".
    local bosh_ports="22 6868 25555"
    local cf_ports="80 443 2222" # seems that 4443 is not used anymore, for good!
    local concourse_ports="8080"
    local mysql_ports="3306"
    for tcp_port in $bosh_ports $cf_ports $concourse_ports $mysql_ports; do
        allowed=$allowed,tcp:$tcp_port
    done

    echo -e "\n${BLUE}Updating ${BOLD}firewall rules$RESET in GCP.\n"
    gcloud compute firewall-rules update "$fw_rule_name" --allow="$allowed"
}

function update_config() {
    local cfg_type=$1; shift # 'cloud' or 'runtime'

    echo -e "\n${BLUE}Updating $BOLD$cfg_type config$RESET in Bosh server.\n"
    pushd "$BASE_DIR/deployments/_${cfg_type}-config"
        source .envrc
        update-${cfg_type}-config "$@"
    popd
}

function each_deployment() {
    local cmd=$1; shift

    local deployments
    deployments=($(find "$BASE_DIR/deployments" -mindepth 1 -maxdepth 1 \
            -type d \! -name bin \! -name '_*' \! -name 'zzz-*' \
            -print \
        | xargs -n 1 basename \
        | sort))
    for depl_name in "${deployments[@]}"; do
        "$cmd" "$depl_name" "$@"
    done
}

function converge() {
    local depl_name=$1; shift

    echo -e "\n${BLUE}Converging the $BOLD'$depl_name'$RESET deployment.\n"
    pushd "$BASE_DIR/deployments/$depl_name"
        source .envrc
        upload-stemcell
        deploy "$@"
    popd
}

function delete() {
    local depl_name=$1; shift

    echo -e "\n${BLUE}Deleting the $BOLD'$depl_name'$RESET deployment.\n"
    pushd "$BASE_DIR/deployments/$depl_name"
        source .envrc
        delete-deployment "$@"
    popd
}

function each_used_release() {
    local cmd=$1; shift

    local stemcell
    stemcell=$(bosh stemcells \
                | awk '{sub("\\*$", "", $2); print $3 "/" $2}' \
                | head -n1)
    local deployments_json
    deployments_json=$(bosh deployments --json)
    local deployments
    deployments=$(echo "$deployments_json" | jq -r '.Tables[0].Rows[] | .name')

    mkdir -p "$BASE_DIR/.cache/compiled-releases"
    pushd "$BASE_DIR/.cache/compiled-releases" > /dev/null

    for depl_name in $deployments; do

        depl_info_json=$(echo "$deployments_json" \
            | jq '.Tables[0].Rows[] | select(.name == "'"$depl_name"'")')

        for release in $(echo "$depl_info_json" | jq -r '.release_s'); do

            base_filename=$(echo "$release" | tr / -)-$(echo "$stemcell" | tr / -)

            "$cmd" "$depl_name" "$release" "$stemcell" "$base_filename" "$@"
        done
    done

    popd > /dev/null
}

function export_release_to_cache() {
    local depl_name=$1; shift
    local release=$1; shift
    local stemcell=$1; shift
    local base_filename=$1; shift

    if [ -n "$(ls "${base_filename}"-*.tgz 2> /dev/null)" ]; then
        echo -e "\n${RED}Existing release$RESET $BOLD$BLUE$release$RESET" \
            "for stemcell $BOLD$GREEN$stemcell$RESET. Skipping.\n"
        return
    fi

    echo -e "\n${BLUE}Exporting release $BOLD$release$RESET" \
        "compiled on stemcell $GREEN$BOLD$stemcell$RESET\n"

    pushd "$BASE_DIR/.cache/compiled-releases"
        bosh -d "$depl_name" export-release "$release" "$stemcell"
    popd
}

function export_releases() {
    assert_utilities jq "to export compiled releases"
    mkdir -p "$BASE_DIR/.cache/compiled-releases"
    each_used_release export_release_to_cache
}

function upload_compiled_releases() {
    if [ ! -d "$BASE_DIR/.cache/compiled-releases" ]; then
        return
    fi
    echo -e "\n${BLUE}Uploading all ${BOLD}compiled releases$RESET found in cache to the BOSH server.\n"
    pushd "$BASE_DIR/.cache/compiled-releases"
        for compiled_release in $(find . -name '*.tgz' | sed -e 's`^./``'); do
            if [[ $compiled_release =~ ^bosh- ]]; then
                continue
            fi
            local release=$(echo "$compiled_release" | sed -e 's/^\([a-z-]*\)-\([0-9.]\{1,\}\)-.*$/\1\/\2/')
            local release_name=$(echo "$release" | cut -d/ -f1)
            local release_version=$(echo "$release" | cut -d/ -f2)
            echo -e "\n${BLUE}Uploading compiled release $BOLD$compiled_release$RESET\n"
            bosh -n upload-release --name="$release_name" --version="$release_version" "$compiled_release"
        done
    popd
}

function echo_stale_release_files() {
    local depl_name=$1; shift
    local release=$1; shift
    local stemcell=$1; shift
    local base_filename=$1; shift

    find . -type f -name "$(echo "$release" | tr / -)*.tgz" \
        | sed -e 's`^\./``' \
        | grep -v "^$base_filename"
}

function cleanup_compiled_releases() {
    local dry_run_arg=$1 # '-n' or something

    assert_utilities jq "to cleanup compiled releases"
    pushd "$BASE_DIR/.cache/compiled-releases"
        declare -a stale_files
        stale_files=($(each_used_release echo_stale_release_files))

        local bosh_version
        bosh_version=$(bosh env | tail -n +3 | head -n 1 | cut -d' ' -f1)
        stale_files+=($(find . -type f -name "bosh-*.tgz" \
                            | sed -e 's`^\./``' \
                            | grep -v "^bosh-${bosh_version}-"))

        if [[ ${#stale_files[@]} -le 0 ]]; then
            echo 0
        else
            du -sk "${stale_files[@]}"
        fi \
            | awk '{T+=$1} END{print "==> This operation is to free approximately " T/1024 " MiB of disk space."}'
        for f in "${stale_files[@]}"; do
            if [ -n "$dry_run_arg" ]; then
                echo "would remove: '$f'"
            else
                rm -v "$f"
            fi
        done
    popd
}

case $1 in
    env)        env_exports ;;
    bbl)        setup_bbl v3.2.6 ;;
    terraform)  setup_terraform 0.9.11 ;;
    bosh)       setup_bosh_cli 2.0.45 ;;
    dnscontrol) setup_dnscontrol 0.2.3 ;;
    gcp)
        shift
        if [[ $# -ne 2 ]]; then
            gcp_usage
            exit 2
        fi
        setup_gcp "$@"
        ;;
    up)
        setup_bbl v3.2.6
        setup_terraform 0.9.11
        setup_bosh_cli 2.0.45
        assert_utilities ruby "to render ERB templates locally"
        pushd "$BASE_DIR"
            source .envrc
            create-env
        popd
        setup_firewall
        ;;
    ip)
        assert_utilities jq "to fetch the main external IP address"
        jq -r .tfState "$BASE_DIR/state/base-env/bbl-state.json" \
            | jq -r .modules[0].outputs.external_ip.value ;;
    down)
        pushd "$BASE_DIR"
            source .envrc
            delete-env
        popd
        ;;
    firewall)   setup_firewall ;;
    ssh)
        pushd "$BASE_DIR"
            source .envrc
            jumpbox
        popd
        ;;
    update)
        shift
        case $1 in
            cloud-config)   shift; update_config cloud "$@";;
            runtime-config) shift; update_config runtime "$@";;
            *)              update_usage ;;
        esac
        ;;
    converge)
        shift
        case $1 in
            -h)
                converge_usage ;;
            "")
                assert_utilities ruby "to render ERB templates locally"
                create-env ;;
            all)
                update_config cloud -n
                update_config runtime -n
                upload_compiled_releases
                each_deployment converge -n
                ;;
            *)
                converge "$@" ;;
        esac
        ;;
    recreate)
        shift
        case $1 in
            -h)
                recreate_usage ;;
            all)
                each_deployment converge -n --recreate --fix --canaries=0 ;;
            *)
                converge "$@" --recreate --fix --canaries=0 ;;
        esac
        ;;
    delete)
        shift
        case $1 in
            -h)
                delete_usage ;;
            all)
                each_deployment delete -n ;;
            *)
                delete "$@" ;;
        esac
        ;;
    export)
        export_releases ;;
    import)
        upload_compiled_releases ;;
    cleanup)
        shift
        cleanup_compiled_releases "$@";;
    *)
        usage; exit 2 ;;
esac

# Local Variables:
# indent-tabs-mode: nil
# End:
