#!/usr/bin/env bash

BASE_DIR=$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")

# White-labeling settings
SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")
project_name=GBE
project_desc="Gstack BOSH Environment"

if ! echo "$PATH" | tr : '\n' | grep -q "^$BASE_DIR/bin$"; then
    # update PATH is not already done by direnv
    PATH=$BASE_DIR/bin:$PATH
fi

source "$BASE_DIR/lib/gbe/colors.inc.bash"
source "$BASE_DIR/lib/gbe/spec.inc.bash"
source "$BASE_DIR/lib/gbe/tunnel.inc.bash"
source "$BASE_DIR/lib/gbe/compiled-releases.inc.bash"
source "$BASE_DIR/lib/gbe/dns.inc.bash"
source "$BASE_DIR/lib/gbe/external-utilities.inc.bash"

function pushd() {
    command pushd "$@" > /dev/null || exit 115
}

function popd() {
    command popd "$@" > /dev/null
}

function fatal() {
    echo "$@" >&2
    exit 1
}

function platform() {
    local system
    # shellcheck disable=SC2018,SC2019
    system=$(uname -s | tr A-Z a-z)
    if [[ $system == darwin || $system == linux ]]; then
        echo "$system"
    else
        fatal "ERROR: unsupported platform: '$system'. Aborting."
    fi
}

function env_usage() {
    local b=$BOLD
    local u=$UNDERLINE
    local rst=$RESET
    local bash_usage="source /dev/stdin <<<\"\$(./bin/$SCRIPT_NAME env)\""
    local zsh_usage="source <\"\$(./bin/$SCRIPT_NAME env)\""
    echo
    local shell_name=$(basename "$SHELL" | tr '[:upper:]' '[:lower:]')
    case $shell_name in
        bash|sh)    usage="$b${u}$bash_usage$rst" ;;
        zsh)        usage="$b${u}$zsh_usage$rst" ;;
        *)          usage="$b${u}$zsh_usage$rst or $b${u}$bash_usage$rst"
    esac
    echo "# Usage: run $usage in your $shell_name shell."
    echo
    echo "# Hint: see the actual environment variables exports" \
        "with $b${u}$SCRIPT_NAME env | cat$rst"
    echo
}

function env_exports() {
    if [ -t 1 ]; then
        # When running in a terminal
        env_usage
        return
    fi

    echo "export PATH=$PATH"

    local env_creds=$(state_dir base-env)/depl-creds.yml
    if [[ ! -f "$env_creds" ]]; then
        return
    fi

    function get_var() {
        local path=$1
        bosh int "$env_creds" --path "$path"
    }

    echo "export BOSH_ALL_PROXY=socks5://127.0.0.1:$TUNNEL_PORT"
    echo "export BOSH_CA_CERT=\"$(get_var /default_ca/ca)\""
    echo "export BOSH_CLIENT=admin"
    echo "export BOSH_CLIENT_SECRET=\"$(get_var /admin_password)\""
    echo "export BOSH_GW_PRIVATE_KEY=\"$(state_dir base-env)/jumpbox.key\""
    echo "export BOSH_ENVIRONMENT=gcp"
    if [ -n "$SUBSYS_DIR" ]; then
        echo "export BOSH_DEPLOYMENT=\"$(spec_var /deployment_vars/deployment_name)\""
    fi
}

function credhub_login() {
    local creds=$(state_dir base-env)/depl-creds.yml

    if [[ ! -f "$creds" || ! -f "$(state_dir base-env)/bbl-state.json" ]]; then
        return
    fi

    export CREDHUB_SERVER=https://$(internal_ip):8844
    export CREDHUB_CA_CERT=$(state_dir base-env)/credhub_CAs.pem
    (
        bosh int "$creds" --path /credhub_ca/certificate
        bosh int "$creds" --path /default_ca/certificate
    ) > "$CREDHUB_CA_CERT"

    export https_proxy=socks5://127.0.0.1:5000

    local credhub_username=credhub-cli
    local credhub_password=$(bosh int "$creds" --path /credhub_cli_password)

    credhub login \
        --username "$credhub_username" \
        --password "$credhub_password"
}

function setup_gcp() {
    local service_account_name=$1
    local project_id=$2

    local service_account_key=$BASE_DIR/base-env/conf/gcp-service-account.key.json
    if [ -f "$service_account_key" ]; then
        echo -e "INFO: the 'gcp-service-account.key.json' credentials file" \
            "already exists in directory '$BASE_DIR/base-env/conf/'. ${BLUE}Skipping${RESET}."
        return 0
    fi

    assert_utilities gcloud "to setup GCP credentials"

    echo -e "${BLUE}Setting ${BOLD}GCP credentials$RESET" \
        "for service account '$service_account_name' and project '$project_id'"

    local had_dash_e
    had_dash_e=$(echo $- | tr -Cd e)
    set -e
    gcloud iam service-accounts create "$service_account_name"
    gcloud iam service-accounts keys create \
        --iam-account="${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        "$service_account_key"
    chmod 600 "$service_account_key"
    gcloud projects add-iam-policy-binding "$project_id" \
        --member="serviceAccount:${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        --role='roles/editor'
    if [ -z "$had_dash_e" ]; then
        set +e
    fi

    local temp_file=$(mktemp)
    sed -e "s/^project_id:.*$/project_id: $project_id/" "$BASE_DIR/base-env/conf/env-infra-vars.yml" > "$temp_file"
    cp "$temp_file" "$BASE_DIR/base-env/conf/env-infra-vars.yml"
    rm "$temp_file"

    echo -e "$GREEN${BOLD}OK$RESET"
}

function usage() {
    echo "$project_name ($project_desc) CLI"
    echo "  $BOLD${MAGENTA}SETUP:$RESET"
    echo "  env         Sourceable envrionment variables for CLI clients"
    echo "  bbl         Installs locally the supported version of Bosh-Bootloader CLI"
    echo "  terraform   Installs locally the supported version of Terraform CLI"
    echo "  bosh        Installs locally the supported version of Bosh CLI"
    echo "  dnscontrol  Installs locally the supported version of DNSControl CLI"
    echo "  gcp         Configures the Google Cloud credentials"
    echo "  firewall    Configures the Google Cloud firewall rules"
    echo "  tunnel      Creates a SSH tunnel to the Bosh server, acting as a SOCKS5 proxy"
    echo
    echo "  $BOLD${MAGENTA}BOSH ENVIRONMENT:$RESET"
    echo "  up          Converges the infrastructure and the Bosh environment towards their desired states"
    echo "  down        Deletes the Bosh environment and the related infrastructure"
    echo "  ip          Outputs the main exernal IP address of the environment"
    echo "  dns         Converge DNS towards the expected DNSControl configuration"
    echo "  ssh         Logs into the Bosh environment VM with SSH"
    echo
    echo "  $BOLD${MAGENTA}MANAGED DEPLOYMENTS:$RESET"
    echo "  update      Updates the cloud config or the runtime config"
    echo "  converge    Converges one or all Bosh deployments towards their desired states"
    echo "  recreate    Recreates one or all Bosh deployments towards their desired states"
    echo "  delete      Deletes one or all Bosh deployments"
    echo
    echo "  $BOLD${MAGENTA}COMPILED RELEASES:$RESET"
    echo "  export      Popoulate the local cache with all compiled releases"
    echo "  import      Import all compiled releases from the cache to the Bosh server"
    echo "  cleanup     Delete stale compiled releases from the cache"
    echo
}

function gcp_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}gcp$noul  <service-account-name>  <project-id>"
    echo
    echo "    <service-account-name>   A name for the service account to be created"
    echo "    <project-id>             The identifier of your GCP project, like 'alpha-sandbox-717101'"
    echo
    echo "Sets the necessary GCP credentials for $project_name:"
    echo "    1. Create the designated service account in GCP."
    echo "    2. Create a service account key in 'conf/gcp-service-account.key.json'."
    echo "    3. Grant to the service account an 'editor' role on the project."
    echo
}

function up_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}up$noul"
    echo
    echo "Creates or converges the Bosh environment VM with 'bosh create-env'."
    echo
    echo "Before the environment is converged, the required utilities are"
    echo "downloaded, if absent."
    echo
    echo "After the environment is converged, a SSH tunnel is started, enabling"
    echo "access the Bosh server. Then the Bosh environnment is referenced in the"
    echo "Bosh CLI config. A use of $ul$SCRIPT_NAME env$noul might be necessary though."
    echo
    echo "Any previously trusted SSH key (from the '~/.ssh/known_hosts') is replaced"
    echo "before the tunnel is started, in case it has changed, to avoid connection"
    echo "issues or hassle."
    echo
}

function down_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}down$noul  [-k]"
    echo
    echo "Destroys the Bosh environment VM and related infrastructure."
    echo
    echo "    -k"
    echo "        Keep infrastructure, which is useful to preserve the allocated IP address."
    echo
}

function dns_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  preview"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  push"
    echo
    echo "Dry-run the DNS congergence with '${b}dnscontrol preview$rst' or"
    echo "actually converge the DNS with '${b}dnscontrol push$rst'."
    echo
}

function tunnel_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  start"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  stop"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  status"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  logs"
    echo
    echo "Start or stop a SOCKS5 compatible SSH tunnel, or get its status, or"
    echo "obtain any logs produced. This tunnel is necessary in order to access"
    echo "the BOSH server, and keep it away from being exposed to the entire"
    echo "Internet, protected behind firewall rules."
    echo
    echo "Environment variables might then need to be be refreshed. Run ${ul}gbe env$noul"
    echo "for more details."
    echo
}

function update_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}update$noul  cloud-config    [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}update$noul  runtime-config  [-n]"
    echo
    echo "Updates the cloud config or the runtime config in BOSH server."
    echo
    echo "    -n"
    echo "        Don't ask for user input"
    echo
    echo "See also:"
    echo "  ${ul}https://bosh.io/docs/cloud-config.html$noul"
    echo "  ${ul}https://bosh.io/docs/runtime-config.html$noul"
    echo
}

function converge_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  [<deployment-name>]  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to converge."
    echo
    echo "Converges one or all deployments towards their desired states,"
    echo "or converge the BOSH environment if no deployment is specified."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any user"
    echo "input. Both cloud config and runtime config will be updated,"
    echo "and all deployments will be converged."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function recreate_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  <deployment-name>  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to recreate."
    echo
    echo "Recreates one or all deployments towards their desired states."
    echo "This command is supposed to recreate deployments that were"
    echo "previously deployed with no errors."
    echo "When specifying ${b}all$rst, the recreation will not ask for any"
    echo "user input."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function delete_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  <deployment-name>  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to delete."
    echo
    echo "Deletes one or all deployments. Persistent disks will typically"
    echo "be kept as orphaned disks for 5 days, but it's hard to rebuild"
    echo "any deployment with those, so this ${b}delete$rst operation is"
    echo "VERY DESTRUCTIVE."
    echo
    echo "When destroying ${b}all$rst deployments, the deletion will not ask"
    echo "for any user input."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input. NOT RECOMMENDED."
    echo
}

function source_env() { # shim
    local rel_dir=$1

    pushd "$rel_dir"
    if [ -f .envrc ]; then
        source .envrc
    fi
    popd
}

function setup_firewall() {
    assert_utilities gcloud "to update firewall rules"

    local fw_rule_name
    fw_rule_name=$(bbl_invoke env-id)-bosh-open

    local allowed=icmp
    # Note: the 'gcloud' CLI v180.0.0 doesn't support the shorter syntax with
    #       semicolons, like "icmp; tcp:22,6868,25555". So we revert to the
    #       more verbose syntax here, e.g. "icmp,tcp:22,tcp:6868,tcp:25555".
    local bosh_ports="22 6868"
    local cf_ports="80 443 2222" # seems that 4443 is not used anymore, for good!
    local concourse_ports="8080"
    local mysql_ports="3306"
    local shield_ports="10443"
    local prometheus_ports="3000 9090 9093"
    for tcp_port in $bosh_ports $cf_ports $concourse_ports $mysql_ports \
                    $shield_ports $prometheus_ports; do
        allowed=$allowed,tcp:$tcp_port
    done

    echo -e "\n${BLUE}Updating ${BOLD}firewall rules$RESET in GCP.\n"
    gcloud compute firewall-rules update "$fw_rule_name" --allow="$allowed"
}

function update_config() {
    local cfg_type=$1; shift # 'cloud' or 'runtime'

    export SUBSYS_DIR=$BASE_DIR/base-env/${cfg_type}-config
    eval "$(env_exports)"

    # Assert subsystem is a BOSH config
    # (meaning: cloud config or runtime config)
    assert_subsys bosh-config

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    read_$(spec_var /subsys/type)_spec
    local subsys_state_dir=$(state_dir)
    mkdir -p "$subsys_state_dir"


    echo -e "\n${BLUE}Updating $BOLD$cfg_type config$RESET in BOSH server.\n"

    bosh interpolate "$MAIN_CONFIG_FILE" \
        "${OPERATIONS_ARGUMENTS[@]}" \
        --vars-file <(spec_var /config_vars) \
        > "$subsys_state_dir/${cfg_type}-config.yml"

    if [ ! -s "$subsys_state_dir/${cfg_type}-config.yml" ]; then
        echo "${cfg_type} config file is empty." \
                "${BLUE}Skipping$RESET update." \
            | awk '{print toupper(substr($0,1,1)) substr($0,2)}'
        exit 0
    fi
    bosh update-${cfg_type}-config "$subsys_state_dir/${cfg_type}-config.yml" "$@"
}

function upload_stemcell() {
    local stemcell_name stemcell_version stemcell_sha1

    stemcell_name=$(spec_var /deployment_vars/stemcell_name)
    stemcell_version=$(spec_var /deployment_vars/stemcell_version)
    stemcell_sha1=$(spec_var /deployment_vars/stemcell_sha1)

    bosh upload-stemcell \
        --name "$stemcell_name" \
        --version "$stemcell_version" \
        --sha1 "$stemcell_sha1" \
        "https://bosh.io/d/stemcells/$stemcell_name?v=$stemcell_version"
}

function each_deployment() {
    local cmd=$1; shift

    local deployments
    deployments=($(find "$BASE_DIR/deployments" -mindepth 1 -maxdepth 1 \
            -type d \! -name bin \! -name '_*' \! -name 'zzz-*' \
            -print \
        | xargs -n 1 basename \
        | sort))
    for depl_name in "${deployments[@]}"; do
        "$cmd" "$depl_name" "$@"
    done
}

function converge_deployment() {
    local depl_name=$1; shift

    echo -e "\n${BLUE}Converging the $BOLD'$depl_name'$RESET deployment.\n"

    export SUBSYS_DIR=$BASE_DIR/deployments/$depl_name
    eval "$(env_exports)"
    upload_stemcell

    assert_subsys bosh-deployment

    set -e

    fetch_input_resources
    read_$(spec_var /subsys/type)_spec

    local subsys_state_dir=$(state_dir)
    mkdir -p "$subsys_state_dir"

    restrict_permissions "$subsys_state_dir/depl-creds.yml"
    bosh_ro_invoke interpolate > "$subsys_state_dir/depl-manifest.yml"

    bosh_rw_invoke deploy "$@"
}

function delete_deployment() {
    local depl_name=$1; shift

    echo -e "\n${BLUE}Deleting the $BOLD'$depl_name'$RESET deployment.\n"

    export SUBSYS_DIR=$BASE_DIR/deployments/$depl_name
    eval "$(env_exports)"
    bosh delete-deployment "$@"
}

function restrict_permissions() {
    local filename=$1

    >> "$filename"
    chmod 600 "$filename"
}

function internal_ip() {
    bosh int <(bbl_invoke bosh-deployment-vars) --path /internal_ip
}

function gbe_up() {
    setup_bbl v3.2.6
    setup_terraform 0.9.11
    setup_bosh_cli 2.0.45
    assert_utilities ruby "to render ERB templates locally"

    # Proxy must not interfere when (re)creating the Bosh environment
    old_BOSH_ALL_PROXY=$BOSH_ALL_PROXY
    stop_tunnel > /dev/null
    unset BOSH_ALL_PROXY

    export SUBSYS_DIR=$BASE_DIR/base-env
    create_env

    # Restore any previous proxy setup, now that Bosh env is (re)created
    if [ -n "$old_BOSH_ALL_PROXY" ]; then
        export BOSH_ALL_PROXY=$old_BOSH_ALL_PROXY
        unset old_BOSH_ALL_PROXY
    fi

    if [ -f ~/.ssh/known_hosts ]; then
        ssh-keygen -f ~/.ssh/known_hosts -R "$(jumpbox_ip)"
    fi
    ssh-keyscan -t ecdsa "$(jumpbox_ip)" 2> /dev/null \
        > ~/.ssh/known_hosts
    start_tunnel

    echo -e "\n${BLUE}Aliasing the created BOSH environment to ${BOLD}'$BOSH_ENVIRONMENT'$RESET\n"

    local env_creds=$(state_dir base-env)/depl-creds.yml
    function get_var() {
        local path=$1
        bosh int "$env_creds" --path "$path"
    }

    eval "$(env_exports)"
    bosh -e "$(internal_ip)" alias-env "$BOSH_ENVIRONMENT"

    setup_firewall
}

function create_env() {

    # Assert subsystem is a bosh-environment
    assert_subsys bosh-environment

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    read_$(spec_var /subsys/type)_spec
    mkdir -p "$(state_dir base-env)"


    echo -e "\n${BLUE}Running ${BOLD}bbl up$RESET to create infrastructure for the BOSH environment\n"

    local bbl_state_file=$(state_dir base-env)/bbl-state.json
    if [[ -f "$bbl_state_file" && ! -s "$bbl_state_file" ]]; then
        # State file might exist and be empty, in which case we must delete it
        # here as a safeguard
        rm -f "$bbl_state_file"
    fi
    bbl_invoke up \
        --iaas "$(spec_var /infra_vars/iaas)" \
        --gcp-region "$(spec_var /infra_vars/region)" \
        --gcp-zone "$(spec_var /infra_vars/zone)" \
        --gcp-service-account-key "$BASE_DIR/base-env/conf/gcp-service-account.key.json" \
        --gcp-project-id "$(spec_var /infra_vars/project_id)" \
        --no-director

    # Ensure restricted permissions for state files containing sensitive
    # informations. Please not that 'bbl-state.json' must not be created before
    # invoking `bbl up`.
    restrict_permissions \
        "$bbl_state_file" \
        "$(state_dir base-env)/depl-creds.yml"


    echo -e "\n${BLUE}Running ${BOLD}dnscontrol push$RESET to converge the external DNS zone\n"

    push_dns_config


    echo -e "\n${BLUE}Running ${BOLD}bosh create-env$RESET to create the BOSH environment\n"

    infra_bosh_ro_invoke interpolate > "$(state_dir base-env)/depl-manifest.yml"
    infra_bosh_rw_invoke create-env

}

function delete_env() {
    export SUBSYS_DIR=$BASE_DIR/base-env

    # Assert subsystem is a bosh-environment
    assert_subsys bosh-environment

    set -e

    echo -e "\n${BLUE}Logging out from credhub and closing SSH tunnel$RESET\n"

    if which credhub > /dev/null; then
        credhub logout
    fi
    stop_tunnel
    unset BOSH_ALL_PROXY


    if [ ! -e "$(state_dir base-env)/depl-creds.yml" ]; then
        echo -e "\n${BLUE}Skipping ${BOLD}bosh delete-env$RESET, as the 'state/base-env/depl-creds.yml' file is absent\n"
    else
        echo -e "\n${BLUE}Running ${BOLD}bosh delete-env$RESET to destroy the BOSH environment\n"
        infra_bosh_rw_invoke delete-env
        rm -vf "$(state_dir base-env)/depl-creds.yml"
    fi


    if [ ! -e "$(state_dir base-env)/jumpbox.key" ]; then
        echo -e "\n${BLUE}Skipping ${BOLD}SSH key removal$RESET, as it is absent\n"
    else
        echo -e "\n${BLUE}Removing ${BOLD}SSH key$RESET from SSH Agent\n"
        ssh-keygen -y -f "$(state_dir base-env)/jumpbox.key" > "$(state_dir base-env)/jumpbox.key.pub"
        if ssh-add -L | grep -qF "$(cat "$(state_dir base-env)/jumpbox.key.pub")"; then
            ssh-add -d "$(state_dir base-env)/jumpbox.key.pub"
        fi
        rm -vf "$(state_dir base-env)/jumpbox.key" "$(state_dir base-env)/jumpbox.key.pub"
        ssh-keygen -f ~/.ssh/known_hosts -R "$(jumpbox_ip)"
    fi

    if [ "x$1" == "x-k" ]; then
        echo -e "\n${BLUE}Skipping ${BOLD}bbl destroy$RESET, as per user request\n"
    elif [ ! -e "$(state_dir base-env)/bbl-state.json" ]; then
        echo -e "\n${BLUE}Skipping ${BOLD}bbl destroy$RESET, as the 'state/bbl-state.json' file is absent\n"
    else
        echo -e "\n${BLUE}Running ${BOLD}bbl destroy$RESET to destroy infrastructure for the BOSH environment\n"
        bbl_invoke destroy --no-confirm --skip-if-missing
    fi
}

case $1 in
    env)        env_exports ;;
    bbl)        setup_bbl v3.2.6 ;;
    terraform)  setup_terraform 0.9.11 ;;
    bosh)       setup_bosh_cli 2.0.45 ;;
    dnscontrol) setup_dnscontrol 0.2.3 ;;

    # FIXME: version 1.5.1 still doesn't support SOCKS5 proxy but
    # there is no publicly available fixed version 1.5.2 yet.
    credhub)    setup_credhub_cli 1.5.3 ; credhub_login ;;

    gcp)
        shift
        if [[ $# -ne 2 ]]; then
            gcp_usage
            exit 2
        fi
        setup_gcp "$@"
        ;;
    up)
        gbe_up ;;
    ip)
        jumpbox_ip | cat ;;
    down)
        shift
        delete_env "$@"
        ;;
    firewall)   setup_firewall ;;
    tunnel)
        shift
        case $1 in
            start)  start_tunnel  ;;
            stop)   stop_tunnel   ;;
            status) tunnel_status ;;
            logs)   tunnel_logs   ;;
            *)      tunnel_usage  ;;
        esac
        ;;
    dns)
        shift
        verb=$1
        case $verb in
            preview)    preview_dns_config ;;
            push)       push_dns_config ;;
            *)          dns_usage ;;
        esac
        ;;
    ssh)
        shift
        ssh_jumpbox "$@"
        ;;
    update)
        shift
        case $1 in
            cloud-config)   shift; update_config cloud "$@";;
            runtime-config) shift; update_config runtime "$@";;
            *)              update_usage ;;
        esac
        ;;
    converge)
        shift
        case $1 in
            -h)
                converge_usage ;;
            "")
                gbe_up ;;
            all)
                upload_compiled_releases
                update_config cloud -n
                update_config runtime -n
                each_deployment converge_deployment -n
                ;;
            deployments)
                update_config cloud -n
                update_config runtime -n
                each_deployment converge_deployment -n
                ;;
            *)
                converge_deployment "$@" ;;
        esac
        ;;
    recreate)
        shift
        case $1 in
            -h)
                recreate_usage ;;
            all)
                each_deployment converge_deployment -n --recreate --fix --canaries=0 ;;
            *)
                converge_deployment "$@" --recreate --fix --canaries=0 ;;
        esac
        ;;
    delete)
        shift
        case $1 in
            ""|-h)
                delete_usage ;;
            all)
                each_deployment delete_deployment -n ;;
            *)
                delete_deployment "$@" ;;
        esac
        ;;
    export)
        export_releases ;;
    import)
        upload_compiled_releases ;;
    cleanup)
        shift
        cleanup_compiled_releases "$@";;
    *)
        usage; exit 2 ;;
esac

# Local Variables:
# indent-tabs-mode: nil
# End:
