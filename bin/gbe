#!/usr/bin/env bash

BASE_DIR=$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")

# White-labeling settings
SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")
project_name=GBE
project_desc="Gstack BOSH Environment"

if ! echo "$PATH" | tr : '\n' | grep -q "^$BASE_DIR/bin$"; then
    # update PATH is not already done by direnv
    PATH=$BASE_DIR/bin:$PATH
fi

source "$BASE_DIR/lib/gbe/colors.inc.bash"

function pushd() {
    command pushd "$@" > /dev/null || exit 115
}

function popd() {
    command popd "$@" > /dev/null
}

function fatal() {
    echo "$@" >&2
    exit 1
}

function platform() {
    local system
    # shellcheck disable=SC2018,SC2019
    system=$(uname -s | tr A-Z a-z)
    if [[ $system == darwin || $system == linux ]]; then
        echo "$system"
    else
        fatal "ERROR: unsupported platform: '$system'. Aborting."
    fi
}

function assert_utilities() {
    local utilities=()

    while # NOTE: emulating do-while, see <https://stackoverflow.com/a/27761760>
        utilities+=("$1"); shift
        [ $# -gt 1 ]
    do :; done
    local reason=$1; shift # last argument

    for utility in "${utilities[@]}"; do
        if ! which "$utility" > /dev/null; then
            fatal "ERROR: $project_name requires '$utility'${reason:+" $reason"}." \
                "Please install it first. Aborting."
        fi
    done
}
function state_dir() {
    local gbe_subsys=${1:-$GBE_SUBSYS}
    if [ -z "$gbe_subsys" ]; then
        echo "ERROR: missing 'GBE_SUBSYS' variable" >&2
        return 1
    fi
    echo "$BASE_DIR/state/$gbe_subsys"
}

function env_usage() {
    local b=$BOLD
    local u=$UNDERLINE
    local rst=$RESET
    local bash_usage="source /dev/stdin <<<\"\$(./bin/$SCRIPT_NAME env)\""
    local zsh_usage="source <\"\$(./bin/$SCRIPT_NAME env)\""
    echo
    local shell_name=$(basename "$SHELL" | tr '[:upper:]' '[:lower:]')
    case $shell_name in
        bash|sh)    usage="$b${u}$bash_usage$rst" ;;
        zsh)        usage="$b${u}$zsh_usage$rst" ;;
        *)          usage="$b${u}$zsh_usage$rst or $b${u}$bash_usage$rst"
    esac
    echo "# Usage: run $usage in your $shell_name shell."
    echo
    echo "# Hint: see the actual environment variables exports" \
        "with $b${u}$SCRIPT_NAME env | cat$rst"
    echo
}

function env_exports() {
    if [ -t 1 ]; then
        # When running in a terminal
        env_usage
        return
    fi

    echo "export PATH=$PATH"

    local env_creds=$(state_dir base-env)/depl-creds.yml
    if [[ ! -f "$env_creds" ]]; then
        return
    fi

    function get_var() {
        local path=$1
        bosh int "$env_creds" --path "$path"
    }

    echo "export BOSH_ALL_PROXY=socks5://127.0.0.1:$TUNNEL_PORT"
    echo "export BOSH_CA_CERT=\"$(get_var /default_ca/ca)\""
    echo "export BOSH_CLIENT=admin"
    echo "export BOSH_CLIENT_SECRET=$(get_var /admin_password)"
    echo "export BOSH_GW_PRIVATE_KEY=\"$(state_dir base-env)/jumpbox.key\""
    echo "export BOSH_ENVIRONMENT=gcp"
}

function setup_bbl() {
    local bbl_version=$1

    if which bbl > /dev/null 2>&1; then
        local existing_bbl_version
        existing_bbl_version=$(bbl --version | head -n 1 | cut -d' ' -f2)
        if [[ $existing_bbl_version =~ ^3\.2\. ]]; then
            return 0
        fi
    fi

    local bbl_bin=$BASE_DIR/bin/bbl
    if [ -f "$bbl_bin" ]; then
        return 0
    fi

    assert_utilities curl "to install bosh-bootloader"

    local bbl_repo=https://github.com/cloudfoundry/bosh-bootloader
    local linux_bin=bbl-${bbl_version}_linux_x86-64
    local darwin_bin=bbl-${bbl_version}_osx

    echo -e "\n${BLUE}Installing ${BOLD}bosh-bootloader CLI$RESET $bbl_version as: $bbl_bin\n"
    local url
    case $(platform) in
        darwin) url=$bbl_repo/releases/download/$bbl_version/$darwin_bin;;
        linux)  url=$bbl_repo/releases/download/$bbl_version/$linux_bin;;
    esac

    curl -sL -o "$bbl_bin" "$url"
    chmod +x "$bbl_bin"
}

function setup_terraform() {
    local tf_version=$1

    if which terraform > /dev/null 2>&1; then
        local existing_tf_version
        existing_tf_version=$(terraform --version | head -n 1 | cut -d' ' -f2)
        if [[ $existing_tf_version =~ ^v0\.9\. ]]; then
            return 0
        fi
    fi

    local tf_bin=$BASE_DIR/bin/terraform
    if [ -f "$tf_bin" ]; then
        return 0
    fi

    assert_utilities curl unzip "to install terraform"

    local base_url=https://releases.hashicorp.com/terraform

    echo -e "${BLUE}Installing ${BOLD}terraform CLI$RESET v$tf_version as: $tf_bin"
    local url
    url=$base_url/$tf_version/terraform_${tf_version}_$(platform)_amd64.zip

    local temp_dir
    temp_dir=$(mktemp -d)
    pushd "$temp_dir"
        curl -sL -o tf.zip "$url"
        unzip tf.zip
        rm tf.zip
        mv terraform "$tf_bin"
        chmod +x "$tf_bin"
    popd
    rm -rf "$temp_dir"
}

function setup_bosh_cli() {
    local bosh_cli_version=$1

    if which bosh > /dev/null 2>&1; then
        local existing_bosh_cli_version
        existing_bosh_cli_version=$(bosh --version | head -n 1 | cut -d' ' -f2 | cut -d- -f1)
        if [[ $existing_bosh_cli_version =~ ^2\.0\. ]]; then
            return 0
        fi
    fi

    local bosh_cli_bin=$BASE_DIR/bin/bosh
    if [ -f "$bosh_cli_bin" ]; then
        return 0
    fi

    assert_utilities curl "to install the Bosh CLI"

    echo -e "${BLUE}Installing ${BOLD}Bosh CLI$RESET v$bosh_cli_version as: $bosh_cli_bin"
    curl -sL "https://s3.amazonaws.com/bosh-cli-artifacts/bosh-cli-${bosh_cli_version}-$(platform)-amd64" \
        -o "$bosh_cli_bin"
    chmod +x "$bosh_cli_bin"
}

function setup_credhub_cli() {
   local credhub_cli_version=$1

    if which credhub > /dev/null 2>&1; then
        local existing_credhub_cli_version
        existing_credhub_cli_version=$(credhub --version | head -n 1 | cut -d: -f2 | tr -d ' ')

        # As version '1.5.2-dev', we currently use the build of branch
        # 'fix-segfault-for-credhub-version' (from remote
        # 'https://github.com/gstackio/credhub-cli.git'), built by
        # Golang v1.9.2, for the SOCKS5 proxy support that version
        # 1.5.1 still doesn't have.

        if [[ $existing_credhub_cli_version =~ ^1\.5\.2 ]]; then
            return 0
        fi
    fi

    local credhub_cli_bin=$BASE_DIR/bin/credhub
    if [ -f "$credhub_cli_bin" ]; then
        return 0
    fi

    assert_utilities curl tar "to install the CredHub CLI"

    local base_url=https://github.com/cloudfoundry-incubator/credhub-cli/releases/download

    echo -e "${BLUE}Installing ${BOLD}CredHub CLI$RESET v$credhub_cli_version as: $credhub_cli_bin"
    local url
    url=$base_url/$credhub_cli_version/credhub-$(platform)-$credhub_cli_version.tgz

    local temp_dir
    temp_dir=$(mktemp -d)
    pushd "$temp_dir"
        curl -sL -o credhub.tgz "$url"
        tar -zxf credhub.tgz
        rm credhub.tgz
        mv credhub "$credhub_cli_bin"
        chmod +x "$credhub_cli_bin"
    popd
    rm -rf "$temp_dir"
}

function credhub_login() {
    local creds=$BASE_DIR/state/base-env/depl-creds.yml

    export CREDHUB_SERVER=https://$(internal_ip):8844
    export CREDHUB_CA_CERT=$(state_dir base-env)/credhub_CAs.pem
    (
        bosh int "$creds" --path /credhub_ca/certificate
        bosh int "$creds" --path /default_ca/certificate
    ) > "$CREDHUB_CA_CERT"

    export https_proxy=socks5://127.0.0.1:5000

    local credhub_username=credhub-cli
    local credhub_password=$(bosh int "$creds" --path /credhub_cli_password)

    credhub login \
        --username "$credhub_username" \
        --password "$credhub_password"
}

function setup_dnscontrol() {
    local dnscontrol_version=$1

    if which dnscontrol > /dev/null 2>&1; then
        return 0
    fi

    local dnscontrol_bin=$BASE_DIR/bin/dnscontrol
    if [ -f "$dnscontrol_bin" ]; then
        return 0
    fi

    assert_utilities curl "to install the DNSControl CLI"

    echo -e "${BLUE}Installing ${BOLD}DNSControl CLI$RESET v$dnscontrol_version as: $dnscontrol_bin"

    local system=$(platform)
    local suffix=$(tr '[:lower:]' '[:upper:]' <<< ${system:0:1})${system:1}
    curl -sL "https://github.com/StackExchange/dnscontrol/releases/download/v$dnscontrol_version/dnscontrol-$suffix" \
        -o "$dnscontrol_bin"
    chmod +x "$dnscontrol_bin"
}

function setup_gcp() {
    local service_account_name=$1
    local project_id=$2

    local service_account_key=$BASE_DIR/base-env/conf/gcp-service-account.key.json
    if [ -f "$service_account_key" ]; then
        echo -e "INFO: the 'gcp-service-account.key.json' credentials file" \
            "already exists in directory '$BASE_DIR/base-env/conf/'. ${BLUE}Skipping${RESET}."
        return 0
    fi

    assert_utilities gcloud "to setup GCP credentials"

    echo -e "${BLUE}Setting ${BOLD}GCP credentials$RESET" \
        "for service account '$service_account_name' and project '$project_id'"

    local had_dash_e
    had_dash_e=$(echo $- | tr -Cd e)
    set -e
    gcloud iam service-accounts create "$service_account_name"
    gcloud iam service-accounts keys create \
        --iam-account="${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        "$service_account_key"
    chmod 600 "$service_account_key"
    gcloud projects add-iam-policy-binding "$project_id" \
        --member="serviceAccount:${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        --role='roles/editor'
    if [ -z "$had_dash_e" ]; then
        set +e
    fi

    local temp_file=$(mktemp)
    sed -e "s/^project_id:.*$/project_id: $project_id/" "$BASE_DIR/base-env/conf/env-infra-vars.yml" > "$temp_file"
    cp "$temp_file" "$BASE_DIR/base-env/conf/env-infra-vars.yml"
    rm "$temp_file"

    echo -e "$GREEN${BOLD}OK$RESET"
}

function usage() {
    echo "$project_name ($project_desc) CLI"
    echo "  $BOLD${MAGENTA}SETUP:$RESET"
    echo "  env         Sourceable envrionment variables for CLI clients"
    echo "  bbl         Installs locally the supported version of Bosh-Bootloader CLI"
    echo "  terraform   Installs locally the supported version of Terraform CLI"
    echo "  bosh        Installs locally the supported version of Bosh CLI"
    echo "  dnscontrol  Installs locally the supported version of DNSControl CLI"
    echo "  gcp         Configures the Google Cloud credentials"
    echo "  firewall    Configures the Google Cloud firewall rules"
    echo "  tunnel      Creates a SSH tunnel to the Bosh server, acting as a SOCKS5 proxy"
    echo
    echo "  $BOLD${MAGENTA}BOSH ENVIRONMENT:$RESET"
    echo "  up          Converges the infrastructure and the Bosh environment towards their desired states"
    echo "  down        Deletes the Bosh environment and the related infrastructure"
    echo "  ip          Outputs the main exernal IP address of the environment"
    echo "  dns         Converge DNS towards the expected DNSControl configuration"
    echo "  ssh         Logs into the Bosh environment VM with SSH"
    echo
    echo "  $BOLD${MAGENTA}MANAGED DEPLOYMENTS:$RESET"
    echo "  update      Updates the cloud config or the runtime config"
    echo "  converge    Converges one or all Bosh deployments towards their desired states"
    echo "  recreate    Recreates one or all Bosh deployments towards their desired states"
    echo "  delete      Deletes one or all Bosh deployments"
    echo
    echo "  $BOLD${MAGENTA}COMPILED RELEASES:$RESET"
    echo "  export      Popoulate the local cache with all compiled releases"
    echo "  import      Import all compiled releases from the cache to the Bosh server"
    echo "  cleanup     Delete stale compiled releases from the cache"
    echo
}

function gcp_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}gcp$noul  <service-account-name>  <project-id>"
    echo
    echo "    <service-account-name>   A name for the service account to be created"
    echo "    <project-id>             The identifier of your GCP project, like 'alpha-sandbox-717101'"
    echo
    echo "Sets the necessary GCP credentials for $project_name:"
    echo "    1. Create the designated service account in GCP."
    echo "    2. Create a service account key in 'conf/gcp-service-account.key.json'."
    echo "    3. Grant to the service account an 'editor' role on the project."
    echo
}

function up_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}up$noul"
    echo
    echo "Creates or converges the Bosh environment VM with 'bosh create-env'."
    echo
    echo "Before the environment is converged, the required utilities are"
    echo "downloaded, if absent."
    echo
    echo "After the environment is converged, a SSH tunnel is started, enabling"
    echo "access the Bosh server. Then the Bosh environnment is referenced in the"
    echo "Bosh CLI config. A use of $ul$SCRIPT_NAME env$noul might be necessary though."
    echo
    echo "Any previously trusted SSH key (from the '~/.ssh/known_hosts') is replaced"
    echo "before the tunnel is started, in case it has changed, to avoid connection"
    echo "issues or hassle."
    echo
}

function down_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}down$noul  [-k]"
    echo
    echo "Destroys the Bosh environment VM and related infrastructure."
    echo
    echo "    -k"
    echo "        Keep infrastructure, which is useful to preserve the allocated IP address."
    echo
}

function dns_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  preview"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  push"
    echo
    echo "Dry-run the DNS congergence with '${b}dnscontrol preview$rst' or"
    echo "actually converge the DNS with '${b}dnscontrol push$rst'."
    echo
}

function tunnel_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  start"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  stop"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  status"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  logs"
    echo
    echo "Start or stop a SOCKS5 compatible SSH tunnel, or get its status, or"
    echo "obtain any logs produced. This tunnel is necessary in order to access"
    echo "the BOSH server, and keep it away from being exposed to the entire"
    echo "Internet, protected behind firewall rules."
    echo
    echo "Environment variables might then need to be be refreshed. Run ${ul}gbe env$noul"
    echo "for more details."
    echo
}

function update_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}update$noul  cloud-config    [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}update$noul  runtime-config  [-n]"
    echo
    echo "Updates the cloud config or the runtime config in BOSH server."
    echo
    echo "    -n"
    echo "        Don't ask for user input"
    echo
    echo "See also:"
    echo "  ${ul}https://bosh.io/docs/cloud-config.html$noul"
    echo "  ${ul}https://bosh.io/docs/runtime-config.html$noul"
    echo
}

function converge_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  [<deployment-name>]  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to converge."
    echo
    echo "Converges one or all deployments towards their desired states,"
    echo "or converge the BOSH environment if no deployment is specified."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any user"
    echo "input. Both cloud config and runtime config will be updated,"
    echo "and all deployments will be converged."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function recreate_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  <deployment-name>  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to recreate."
    echo
    echo "Recreates one or all deployments towards their desired states."
    echo "This command is supposed to recreate deployments that were"
    echo "previously deployed with no errors."
    echo "When specifying ${b}all$rst, the recreation will not ask for any"
    echo "user input."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function delete_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local b=$BOLD
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  <deployment-name>  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  all"
    echo
    echo "    <deployment-name>   The name of a deployment to delete."
    echo
    echo "Deletes one or all deployments. Persistent disks will typically"
    echo "be kept as orphaned disks for 5 days, but it's hard to rebuild"
    echo "any deployment with those, so this ${b}delete$rst operation is"
    echo "VERY DESTRUCTIVE."
    echo
    echo "When destroying ${b}all$rst deployments, the deletion will not ask"
    echo "for any user input."
    echo
    echo "    -n"
    echo "        Run unattended. Don't ask for user input. NOT RECOMMENDED."
    echo
}

function source_env() { # shim
    local rel_dir=$1

    pushd "$rel_dir"
    if [ -f .envrc ]; then
        source .envrc
    fi
    popd
}

function bbl_invoke() {
    bbl --state-dir "$(state_dir base-env)" "$@"
}

function setup_firewall() {
    assert_utilities gcloud "to update firewall rules"

    local fw_rule_name
    fw_rule_name=$(bbl_invoke env-id)-bosh-open

    local allowed=icmp
    # Note: the 'gcloud' CLI v180.0.0 doesn't support the shorter syntax with
    #       semicolons, like "icmp; tcp:22,6868,25555". So we revert to the
    #       more verbose syntax here, e.g. "icmp,tcp:22,tcp:6868,tcp:25555".
    local bosh_ports="22 6868"
    local cf_ports="80 443 2222" # seems that 4443 is not used anymore, for good!
    local concourse_ports="8080"
    local mysql_ports="3306"
    local shield_ports="10443"
    local prometheus_ports="3000 9090 9093"
    for tcp_port in $bosh_ports $cf_ports $concourse_ports $mysql_ports \
                    $shield_ports $prometheus_ports; do
        allowed=$allowed,tcp:$tcp_port
    done

    echo -e "\n${BLUE}Updating ${BOLD}firewall rules$RESET in GCP.\n"
    gcloud compute firewall-rules update "$fw_rule_name" --allow="$allowed"
}

function update_config() {
    local cfg_type=$1; shift # 'cloud' or 'runtime'

    echo -e "\n${BLUE}Updating $BOLD$cfg_type config$RESET in Bosh server.\n"
    pushd "$BASE_DIR/deployments/_${cfg_type}-config"
        source .envrc
        update-${cfg_type}-config "$@"
    popd
}

function each_deployment() {
    local cmd=$1; shift

    local deployments
    deployments=($(find "$BASE_DIR/deployments" -mindepth 1 -maxdepth 1 \
            -type d \! -name bin \! -name '_*' \! -name 'zzz-*' \
            -print \
        | xargs -n 1 basename \
        | sort))
    for depl_name in "${deployments[@]}"; do
        "$cmd" "$depl_name" "$@"
    done
}

function converge() {
    local depl_name=$1; shift

    echo -e "\n${BLUE}Converging the $BOLD'$depl_name'$RESET deployment.\n"
    pushd "$BASE_DIR/deployments/$depl_name"
        source .envrc
        upload-stemcell
        deploy "$@"
    popd
}

function delete() {
    local depl_name=$1; shift

    echo -e "\n${BLUE}Deleting the $BOLD'$depl_name'$RESET deployment.\n"
    pushd "$BASE_DIR/deployments/$depl_name"
        source .envrc
        delete-deployment "$@"
    popd
}

function each_used_release() {
    local cmd=$1; shift

    local stemcell
    stemcell=$(bosh stemcells \
                | awk '{sub("\\*$", "", $2); print $3 "/" $2}' \
                | head -n1)
    local deployments_json
    deployments_json=$(bosh deployments --json)
    local deployments
    deployments=$(echo "$deployments_json" | jq -r '.Tables[0].Rows[] | .name')

    mkdir -p "$BASE_DIR/.cache/compiled-releases"
    pushd "$BASE_DIR/.cache/compiled-releases" > /dev/null

    for depl_name in $deployments; do

        depl_info_json=$(echo "$deployments_json" \
            | jq '.Tables[0].Rows[] | select(.name == "'"$depl_name"'")')

        for release in $(echo "$depl_info_json" | jq -r '.release_s'); do

            base_filename=$(echo "$release" | tr / -)-$(echo "$stemcell" | tr / -)

            "$cmd" "$depl_name" "$release" "$stemcell" "$base_filename" "$@"
        done
    done

    popd > /dev/null
}

function export_release_to_cache() {
    local depl_name=$1; shift
    local release=$1; shift
    local stemcell=$1; shift
    local base_filename=$1; shift

    if [ -n "$(ls "${base_filename}"-*.tgz 2> /dev/null)" ]; then
        echo -e "\n${RED}Existing release$RESET $BOLD$BLUE$release$RESET" \
            "for stemcell $BOLD$GREEN$stemcell$RESET. Skipping.\n"
        return
    fi

    echo -e "\n${BLUE}Exporting release $BOLD$release$RESET" \
        "compiled on stemcell $GREEN$BOLD$stemcell$RESET\n"

    pushd "$BASE_DIR/.cache/compiled-releases"
        bosh -d "$depl_name" export-release "$release" "$stemcell"
    popd
}

function export_releases() {
    assert_utilities jq "to export compiled releases"
    mkdir -p "$BASE_DIR/.cache/compiled-releases"
    each_used_release export_release_to_cache
}

function upload_compiled_releases() {
    if [ ! -d "$BASE_DIR/.cache/compiled-releases" ]; then
        return
    fi
    echo -e "\n${BLUE}Uploading all ${BOLD}compiled releases$RESET found in cache to the BOSH server.\n"
    pushd "$BASE_DIR/.cache/compiled-releases"
        for compiled_release in $(find . -name '*.tgz' | sed -e 's`^./``'); do
            if [[ $compiled_release =~ ^bosh- ]]; then
                continue
            fi
            local release=$(echo "$compiled_release" | sed -e 's/^\([a-z-]*\)-\([0-9.]\{1,\}\)-.*$/\1\/\2/')
            local release_name=$(echo "$release" | cut -d/ -f1)
            local release_version=$(echo "$release" | cut -d/ -f2)
            echo -e "\n${BLUE}Uploading compiled release $BOLD$compiled_release$RESET\n"
            bosh -n upload-release --name="$release_name" --version="$release_version" "$compiled_release"
        done
    popd
}

function echo_stale_release_files() {
    local depl_name=$1; shift
    local release=$1; shift
    local stemcell=$1; shift
    local base_filename=$1; shift

    local release_name=$(echo "$release" | cut -d/ -f1)

    find . -type f -name "${release_name}*.tgz" \
        | sed -e 's`^\./``' \
        | grep -v "^$base_filename"
}

function cleanup_compiled_releases() {
    local dry_run_arg=$1 # '-n' or something

    assert_utilities jq "to cleanup compiled releases"
    pushd "$BASE_DIR/.cache/compiled-releases"
        declare -a stale_files
        stale_files=($(each_used_release echo_stale_release_files))

        local bosh_version
        bosh_version=$(bosh env | tail -n +3 | head -n 1 | cut -d' ' -f1)
        stale_files+=($(find . -type f -name "bosh-*.tgz" \
                            | sed -e 's`^\./``' \
                            | grep -v "^bosh-${bosh_version}-"))

        if [[ ${#stale_files[@]} -le 0 ]]; then
            echo 0
        else
            du -sk "${stale_files[@]}"
        fi \
            | awk '{T+=$1} END{print "==> This operation is to free approximately " T/1024 " MiB of disk space."}'
        for f in "${stale_files[@]}"; do
            if [ -n "$dry_run_arg" ]; then
                echo "would remove: '$f'"
            else
                rm -v "$f"
            fi
        done
    popd
}

function restrict_permissions() {
    local filename=$1

    >> "$filename"
    chmod 600 "$filename"
}

function jumpbox_key() {
    restrict_permissions "$(state_dir base-env)/jumpbox.key"
    bosh int "$(state_dir base-env)/depl-creds.yml" --path /jumpbox_ssh/private_key \
         > "$(state_dir base-env)/jumpbox.key"
}

function jumpbox_ip() {
    bosh int <(bbl_invoke bosh-deployment-vars) --path /external_ip
}

function has_tunnel() {
    local pid_file=$(state_dir base-env)/ssh-tunnel.pid
    [ -s "$pid_file" ] && ps -p "$(cat "$pid_file")" > /dev/null
}

TUNNEL_PORT=5000

function setup_tunnel() {
    local local_port=$1

    local pid_file=$(state_dir base-env)/ssh-tunnel.pid
    if has_tunnel "$pid_file"; then
        return 0
    fi

    echo -e "\n${BLUE}Opening the ${BOLD}SSH tunnel$RESET that enables access to the Bosh server\n"

    jumpbox_key

    nohup ssh -4 -D "localhost:$local_port" -fNC \
            -i "$(state_dir base-env)/jumpbox.key" "jumpbox@$(jumpbox_ip)" \
        > "$(state_dir base-env)/ssh-tunnel.log"
    lsof -i ":$local_port" \
        | grep -E '^ssh\b' | awk '{print $2}' \
        > "$pid_file"
}

function start_tunnel() {
    local pid_file=$(state_dir base-env)/ssh-tunnel.pid
    if has_tunnel "$pid_file"; then
        echo -e "\n${BLUE}SSH tunnel is ${BOLD}already running$RESET on PID '$(cat "$pid_file")'" \
             "(more info with ${UNDERLINE}lsof -i :$local_port$RESET)\n"
        return 1
    fi
    setup_tunnel "$TUNNEL_PORT"
    if [ "$BOSH_ALL_PROXY" != "socks5://127.0.0.1:$TUNNEL_PORT" ]; then
        echo
        echo "${BLUE}You must ${BOLD}refresh your environment variables${RESET} like this:"
        env_usage
    fi
}

function tunnel_status() {
    local pid_file=$(state_dir base-env)/ssh-tunnel.pid
    if ! has_tunnel; then
        echo -e "\nSSH tunnel is $RED${BOLD}not running$RESET\n"
    else
        echo -e "\nSSH tunnel is $GREEN${BOLD}is running$RESET on PID '$(cat "$pid_file")'\n"
        echo -e "${BOLD}Details:$RESET"
        lsof -i ":$TUNNEL_PORT"
        echo
    fi
}

function tunnel_logs() {
    echo -e "${BOLD}Last logs:$RESET"
    tail "$(state_dir base-env)/ssh-tunnel.log"
}

function stop_tunnel() {
    local pid_file=$(state_dir base-env)/ssh-tunnel.pid
    if has_tunnel "$pid_file"; then
        echo -e "\n${BLUE}Closing the ${BOLD}SSH tunnel$RESET that enables access to the Bosh server\n"
        kill "$(cat "$pid_file")"
    fi
    rm -f "$pid_file"
}

function internal_ip() {
    bosh int <(bbl_invoke bosh-deployment-vars) --path /internal_ip
}

function gbe_up() {
    setup_bbl v3.2.6
    setup_terraform 0.9.11
    setup_bosh_cli 2.0.45
    assert_utilities ruby "to render ERB templates locally"
    pushd "$BASE_DIR"
        source .envrc
        create-env
    popd
    setup_firewall
}

function ssh_jumpbox() {
    if [ ! -f "$(state_dir base-env)/depl-creds.yml" ]; then
        echo "$SCRIPT_NAME: ERROR: the base BOSH environment is not created yet" \
             "Please create it first. Aborting." >&2
        exit 1
    fi

    local timeout_arg
    case $(platform) in
        darwin) timeout_arg=-t ;;
        linux)  timeout_arg=-W ;;
    esac
    local jumpbox_ip=$(jumpbox_ip)

    # Wait for target to respond to ping
    while ! ping -q -c 1 $timeout_arg 3 "$jumpbox_ip" > /dev/null; do
        echo "$(date +'%F %T') waiting $jumpbox_ip to respond to ping"
        sleep 2
        status=$?
        if [ "$status" -gt 128 ]; then
            # When interrupted by a signal, abort with same status
            exit $status
        fi
    done

    TERM=xterm-color ssh \
        -i "$(state_dir base-env)/jumpbox.key" \
        "jumpbox@$(jumpbox_ip)" \
        "$@"
}

case $1 in
    env)        env_exports ;;
    bbl)        setup_bbl v3.2.6 ;;
    terraform)  setup_terraform 0.9.11 ;;
    bosh)       setup_bosh_cli 2.0.45 ;;
    dnscontrol) setup_dnscontrol 0.2.3 ;;

    # FIXME: version 1.5.1 still doesn't support SOCKS5 proxy but
    # there is no publicly available fixed version 1.5.2 yet.
    credhub)    setup_credhub_cli 1.5.1 ; credhub_login ;;

    gcp)
        shift
        if [[ $# -ne 2 ]]; then
            gcp_usage
            exit 2
        fi
        setup_gcp "$@"
        ;;
    up)
        gbe_up ;;
    ip)
        jumpbox_ip ;;
    down)
        shift
        pushd "$BASE_DIR"
            source .envrc
            delete-env "$@"
        popd
        ;;
    firewall)   setup_firewall ;;
    tunnel)
        shift
        case $1 in
            start)  start_tunnel  ;;
            stop)   stop_tunnel   ;;
            status) tunnel_status ;;
            logs)   tunnel_logs   ;;
            *)      tunnel_usage  ;;
        esac
        ;;
    dns)
        shift
        verb=$1
        case $verb in
            preview|push) "$BASE_DIR/dns/bin/$verb" ;;
            *)            dns_usage ;;
        esac
        ;;
    ssh)
        shift
        setup_tunnel "$TUNNEL_PORT"
        ssh_jumpbox "$@"
        ;;
    update)
        shift
        case $1 in
            cloud-config)   shift; update_config cloud "$@";;
            runtime-config) shift; update_config runtime "$@";;
            *)              update_usage ;;
        esac
        ;;
    converge)
        shift
        case $1 in
            -h)
                converge_usage ;;
            "")
                gbe_up ;;
            all)
                update_config cloud -n
                update_config runtime -n
                upload_compiled_releases
                each_deployment converge -n
                ;;
            deployments)
                update_config cloud -n
                update_config runtime -n
                each_deployment converge -n
                ;;
            *)
                converge "$@" ;;
        esac
        ;;
    recreate)
        shift
        case $1 in
            -h)
                recreate_usage ;;
            all)
                each_deployment converge -n --recreate --fix --canaries=0 ;;
            *)
                converge "$@" --recreate --fix --canaries=0 ;;
        esac
        ;;
    delete)
        shift
        case $1 in
            ""|-h)
                delete_usage ;;
            all)
                each_deployment delete -n ;;
            *)
                delete "$@" ;;
        esac
        ;;
    export)
        export_releases ;;
    import)
        upload_compiled_releases ;;
    cleanup)
        shift
        cleanup_compiled_releases "$@";;
    *)
        usage; exit 2 ;;
esac

# Local Variables:
# indent-tabs-mode: nil
# End:
