#!/usr/bin/env bash

set -o pipefail

BASE_DIR=$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")
readonly BASE_DIR

# White-labeling settings
SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")
project_name=GBE
project_desc="Gstack BOSH Environment"

if ! echo "$PATH" | tr : '\n' | grep -q "^$BASE_DIR/bin$"; then
    # update PATH is not already done by direnv
    PATH=$BASE_DIR/bin:$PATH
fi

source "$BASE_DIR/lib/gbe/colors.inc.bash"
source "$BASE_DIR/lib/gbe/spec.inc.bash"
source "$BASE_DIR/lib/gbe/tunnel.inc.bash"
source "$BASE_DIR/lib/gbe/compiled-releases.inc.bash"
source "$BASE_DIR/lib/gbe/dns.inc.bash"
source "$BASE_DIR/lib/gbe/external-utilities.inc.bash"
source "$BASE_DIR/lib/gbe/hooks.inc.bash"

function pushd() {
    command pushd "$@" > /dev/null || exit 115
}

function popd() {
    command popd "$@" > /dev/null
}

function fatal() {
    echo "$@" >&2
    exit 1
}

function platform() {
    local system
    # shellcheck disable=SC2018,SC2019
    system=$(uname -s | tr A-Z a-z)
    if [[ $system == darwin || $system == linux ]]; then
        echo "$system"
    else
        fatal "${RED}ERROR:$RESET unsupported platform: '$system'. Aborting."
    fi
}

function env_usage() {
    local b=$BOLD
    local u=$UNDERLINE
    local rst=$RESET
    local bash_usage="source /dev/stdin <<<\"\$($0 env)\""
    local zsh_usage="source <\"\$(./bin/$SCRIPT_NAME env)\""
    echo
    local shell_name=$(basename "$SHELL" | tr '[:upper:]' '[:lower:]')
    case $shell_name in
        bash|sh)    usage="$b${u}$bash_usage$rst" ;;
        zsh)        usage="$b${u}$zsh_usage$rst" ;;
        *)          usage="$b${u}$zsh_usage$rst or $b${u}$bash_usage$rst" ;;
    esac
    echo "# Usage: run $usage in your $shell_name shell."
    echo
    echo "# Hint: see the actual environment variables exports" \
        "with $b${u}$SCRIPT_NAME env | cat$rst"
    echo
}

function env_exports() {
    if [ -t 1 ]; then
        # When running in a terminal
        env_usage
        return
    fi

    echo "export PATH=$PATH"

    local env_creds=$(state_dir "$GBE_ENVIRONMENT")/depl-creds.yml
    if [[ ! -f "$env_creds" ]]; then
        return
    fi

    function get_var() {
        local path=$1
        bosh int "$env_creds" --path "$path"
    }

    env_exports_hook
    echo "export BOSH_CA_CERT=\"$(get_var /default_ca/ca)\""
    echo "export BOSH_CLIENT=admin"
    echo "export BOSH_CLIENT_SECRET=\"$(get_var /admin_password)\""
    echo "export BOSH_GW_PRIVATE_KEY=\"$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key\""
    echo "export BOSH_ENVIRONMENT=\"$(spec_var /infra_vars/alias "$BASE_DIR/$GBE_ENVIRONMENT")\""
    if [ -n "$SUBSYS_DIR" ]; then
        echo "export BOSH_DEPLOYMENT=\"$(spec_var /deployment_vars/deployment_name)\""
    fi
}

function credhub_login() {
    local creds=$(state_dir "$GBE_ENVIRONMENT")/depl-creds.yml

    if [[ ! -f "$creds" || ! -f "$(state_dir "$GBE_ENVIRONMENT")/bbl-state.json" ]]; then
        return
    fi

    export CREDHUB_SERVER=https://$(internal_ip):8844
    export CREDHUB_CA_CERT=$(state_dir "$GBE_ENVIRONMENT")/credhub_CAs.pem
    (
        bosh int "$creds" --path /credhub_ca/certificate
        bosh int "$creds" --path /default_ca/certificate
    ) > "$CREDHUB_CA_CERT"

    export https_proxy=socks5://127.0.0.1:5000

    local credhub_username=credhub-cli
    local credhub_password=$(bosh int "$creds" --path /credhub_cli_password)

    credhub login \
        --username "$credhub_username" \
        --password "$credhub_password"
}

function setup_gcp() {
    local service_account_name=$1
    local project_id=$2

    local service_account_key=$BASE_DIR/$GBE_ENVIRONMENT/conf/gcp-service-account.key.json
    if [ -f "$service_account_key" ]; then
        echo -e "INFO: the 'gcp-service-account.key.json' credentials file" \
            "already exists in directory '$BASE_DIR/$GBE_ENVIRONMENT/conf/'. ${BLUE}Skipping${RESET}."
        return 0
    fi

    assert_utilities gcloud "to setup GCP credentials"

    echo -e "${BLUE}Setting ${BOLD}GCP credentials$RESET" \
        "for service account '$service_account_name' and project '$project_id'"

    local had_dash_e
    had_dash_e=$(echo $- | tr -Cd e)
    set -e
    gcloud iam service-accounts create "$service_account_name"
    gcloud iam service-accounts keys create \
        --iam-account="${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        "$service_account_key"
    chmod 600 "$service_account_key"
    gcloud projects add-iam-policy-binding "$project_id" \
        --member="serviceAccount:${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        --role='roles/editor'
    if [ -z "$had_dash_e" ]; then
        set +e
    fi

    local temp_file=$(mktemp)
    sed -e "s/^  project_id:.*$/project_id: $project_id/" "$BASE_DIR/$GBE_ENVIRONMENT/conf/spec.yml" > "$temp_file"
    cp "$temp_file" "$BASE_DIR/$GBE_ENVIRONMENT/conf/spec.yml"
    rm "$temp_file"

    echo -e "$GREEN${BOLD}OK$RESET"
}

function usage() {
    echo "$project_name ($project_desc) CLI"
    echo "  $BOLD${MAGENTA}SETUP:$RESET"
    echo "  env         Sourceable envrionment variables for CLI clients"
    echo "  gcp         Configures the Google Cloud credentials"
    echo "  firewall    Configures the Google Cloud firewall rules"
    echo "  tunnel      Creates a SSH tunnel to the Bosh server, acting as a SOCKS5 proxy"
    echo
    echo "  $BOLD${MAGENTA}BOSH ENVIRONMENT:$RESET"
    echo "  up          Converges the infrastructure and the Bosh environment towards their desired states"
    echo "  down        Deletes the Bosh environment and the related infrastructure"
    echo "  ip          Outputs the main exernal IP address of the environment"
    echo "  dns         Converge DNS towards the expected DNSControl configuration"
    echo "  ssh         Logs into the Bosh environment VM with SSH"
    echo
    echo "  $BOLD${MAGENTA}MANAGED DEPLOYMENTS:$RESET"
    echo "  update      Updates the cloud config or the runtime config"
    echo "  converge    Converges one or all Bosh deployments towards their desired states"
    echo "  recreate    Recreates one or all Bosh deployments towards their desired states"
    echo "  delete      Deletes one or all Bosh deployments"
    echo
    echo "  $BOLD${MAGENTA}UTILITIES SETUP:$RESET"
    echo "  bbl         Installs locally the supported version of Bosh-Bootloader CLI"
    echo "  terraform   Installs locally the supported version of Terraform CLI"
    echo "  bosh        Installs locally the supported version of Bosh CLI"
    echo "  dnscontrol  Installs locally the supported version of DNSControl CLI"
    echo "  cf          Installs locally the supported version of Cloud Foundry CLI"
    echo
    echo "  $BOLD${MAGENTA}COMPILED RELEASES:$RESET"
    echo "  export      Popoulate the local cache with all compiled releases"
    echo "  import      Import all compiled releases from the cache to the Bosh server"
    echo "  cleanup     Delete stale compiled releases from the cache"
    echo
}

function gcp_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}gcp$noul  <service-account-name>  <project-id>"
    echo
    echo "    <service-account-name>   A name for the service account to be created"
    echo "    <project-id>             The identifier of your GCP project, like 'alpha-sandbox-717101'"
    echo
    echo "Sets the necessary GCP credentials for $project_name:"
    echo "    1. Create the designated service account in GCP."
    echo "    2. Create a service account key in 'conf/gcp-service-account.key.json'."
    echo "    3. Grant to the service account an 'editor' role on the project."
    echo
}

function up_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}up$noul"
    echo
    echo "Creates or converges the Bosh environment VM with 'bosh create-env'."
    echo
    echo "Before the environment is converged, the required utilities are"
    echo "downloaded, if absent."
    echo
    echo "After the environment is converged, a SSH tunnel is started, enabling"
    echo "access the Bosh server. Then the Bosh environnment is referenced in the"
    echo "Bosh CLI config. A use of $ul$SCRIPT_NAME env$noul might be necessary though."
    echo
    echo "Any previously trusted SSH key (from the '~/.ssh/known_hosts') is replaced"
    echo "before the tunnel is started, in case it has changed, to avoid connection"
    echo "issues or hassle."
    echo
}

function down_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}down$noul  [-k]"
    echo
    echo "Destroys the Bosh environment VM and related infrastructure."
    echo
    echo "    -k"
    echo "        Keep infrastructure, which is useful to preserve the allocated IP address."
    echo
}

function dns_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  preview"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  push"
    echo
    echo "Dry-run the DNS congergence with '${b}dnscontrol preview$rst' or"
    echo "actually converge the DNS with '${b}dnscontrol push$rst'."
    echo
}

function tunnel_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  start"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  stop"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  status"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  logs"
    echo
    echo "Start or stop a SOCKS5 compatible SSH tunnel, or get its status, or"
    echo "obtain any logs produced. This tunnel is necessary in order to access"
    echo "the BOSH server, and keep it away from being exposed to the entire"
    echo "Internet, protected behind firewall rules."
    echo
    echo "Environment variables might then need to be be refreshed. Run ${ul}gbe env$noul"
    echo "for more details."
    echo
}

function update_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}update$noul  cloud-config    [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}update$noul  runtime-config  [-n]"
    echo
    echo "Updates the cloud config or the runtime config in BOSH server."
    echo
    echo "    -n"
    echo "        Don't ask for user input"
    echo
    echo "See also:"
    echo "  ${ul}https://bosh.io/docs/cloud-config.html$noul"
    echo "  ${ul}https://bosh.io/docs/runtime-config.html$noul"
    echo
}

function converge_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  [<subsys-name>]  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  all"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  list"
    echo
    echo "    <subsys-name>   The name of a subsys to converge."
    echo
    echo "Converges one or all subsystems towards their desired states,"
    echo "or converge the BOSH environment if no subsystem is specified."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any user"
    echo "input. Both cloud config and runtime config will be updated,"
    echo "and all subsystems will be converged."
    echo
    echo "When specifying ${b}list$rst, the list of subsystems to converge is"
    echo "displayed, in the order ${b}gbe converge all$rst would treat them."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function recreate_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  <subsys-name>  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  all"
    echo
    echo "    <subsys-name>   The name of a subsys to recreate."
    echo
    echo "Recreates one or all subsystems towards their desired states."
    echo "This command is supposed to recreate subsystems that were"
    echo "previously deployed with no errors."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any"
    echo "user input."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function delete_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  <subsys-name>  [-n]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  all"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  list"
    echo
    echo "    <subsys-name>   The name of a subsys to delete."
    echo
    echo "Deletes one or all subsystems. Persistent disks will typically be"
    echo "kept by BOSH as orphaned disks for 5 days, but it's hard to rebuild"
    echo "any deployment with those, so this ${b}delete$rst operation is"
    echo "VERY DESTRUCTIVE."
    echo
    echo "When destroying ${b}all$rst subsystems, the deletion will not ask"
    echo "for any user input."
    echo
    echo "When specifying ${b}list$rst, the list of subsystems to delete is"
    echo "displayed, in the order ${b}gbe delete all$rst would treat them."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input. NOT RECOMMENDED."
    echo
}

function export_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}export$noul  [<subsys-name>]"
    echo
    echo "    <subsys-name>   The name of a subsys of type 'bosh-deployment'."
    echo
    echo "Exports all compiled releases going through each deployments"
    echo "currently managed by the BOSH server."
    echo
    echo "When specifying a subsys name, the set of exported releases is"
    echo "restricted to those that are necessary to the deployment that is"
    echo "related to the subsys. This subsys must be of type 'bosh-deployment'"
    echo "and the related deployment must exist in the BOSH server."
    echo
}

function import_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}import$noul  [<subsys-name>]"
    echo
    echo "    <subsys-name>   The name of a subsys of type 'bosh-deployment'."
    echo
    echo "Imports all compiled releases going through each deployments"
    echo "currently managed by the BOSH server."
    echo
    echo "When specifying a subsys name, the exported BOSH releases are those"
    echo "that are necessary to the BOSH deployment that the subsys describes."
    echo "This subsys must be of type 'bosh-deployment' and there must be a"
    echo "subfolder of that name in the '.cache/compiled-releases/' directory."
    echo
}

function setup_firewall() {
    setup_firewall_hook
}

function ensure_reachability() {
    ensure_reachability_hook
}

function add_routes() {
    local rendered_cloud_config=$(state_dir cloud-config)/cloud-config.yml
    if [ ! -e "$rendered_cloud_config" ]; then
        fatal "${RED}ERROR:$RESET please run 'gbe update cloud-config'" \
            "before running 'gbe routes'. Aborting."
    fi
    local network_cidr
    network_cidr=$(bosh int "$rendered_cloud_config" --path /networks/name=default/subnets/0/range)
    local netstat_pattern
    local platform=$(platform)
    case $platform in
        darwin) netstat_pattern=$(echo "$network_cidr" | sed -e 's/\.0//g') ;;
        linux)  netstat_pattern=$(echo "$netstat_cidr" \
                                        | sed -e 's`/.*$``; s/\./\\./g') ;;
    esac
    if netstat -nr | awk '{print $1}' | grep -qE "^$netstat_pattern\$"; then
        return
    fi
    case $platform in
        darwin) sudo route add -net "$network_cidr"    $(internal_ip) ;;
        linux)  sudo route add -net "$network_cidr" gw $(internal_ip) ;;
    esac
}

function update_config() {
    local cfg_type=$1; shift # 'cloud' or 'runtime'

    export SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT/${cfg_type}-config
    eval "$(env_exports)"

    # Assert subsystem is a BOSH config
    # (meaning: cloud config or runtime config)
    assert_subsys bosh-config

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    "read_$(spec_var /subsys/type)_spec"
    local subsys_state_dir=$(state_dir)
    mkdir -p "$subsys_state_dir"


    echo -e "\n${BLUE}Updating $BOLD$cfg_type config$RESET in BOSH server.\n"

    bosh interpolate "$MAIN_CONFIG_FILE" \
        "${OPERATIONS_ARGUMENTS[@]}" \
        --vars-file <(spec_var /config_vars) \
        --vars-file <(imported_vars) \
        > "$subsys_state_dir/${cfg_type}-config.yml"

    if [ ! -s "$subsys_state_dir/${cfg_type}-config.yml" ]; then
        echo "${cfg_type} config file is empty." \
                "${BLUE}Skipping$RESET update." \
            | awk '{print toupper(substr($0,1,1)) substr($0,2)}'
        exit 0
    fi
    bosh update-${cfg_type}-config "$subsys_state_dir/${cfg_type}-config.yml" "$@"
}

function upload_stemcell() {
    local stemcell_name stemcell_version stemcell_sha1

    stemcell_name=$(spec_var /deployment_vars/stemcell_name) || true
    stemcell_version=$(spec_var /deployment_vars/stemcell_version) || true
    stemcell_sha1=$(spec_var /deployment_vars/stemcell_sha1) || true

    if [ -z "$stemcell_name" -o -z "$stemcell_version" -o -z "$stemcell_sha1" ]; then
        return
    fi

    bosh upload-stemcell \
        --name "$stemcell_name" \
        --version "$stemcell_version" \
        --sha1 "$stemcell_sha1" \
        "https://bosh.io/d/stemcells/$stemcell_name?v=$stemcell_version"
}

function list_deployments() {
    echo -e "\n$BLUE${BOLD}Affected deployments$RESET in order:\n"
    each_deployment "$@" print_deployment_name
    echo
}

function print_deployment_name() {
    local depl_name=$1
    echo "  - $depl_name"
}

function each_deployment() {
    local reverse_arg cmd
    if [ "x$1" == x-r -o "x$1" == x--reverse ]; then
        reverse_arg=$1; shift
    fi
    cmd=$1; shift

    local old_IFS subsys_dirs
    old_IFS=$IFS
    IFS=$'\n'
    subsys_dirs=($(find "$BASE_DIR/deployments" -mindepth 1 -maxdepth 1 \
            -type d \! -name 'zzz-*' \
            -print))
    IFS=$old_IFS

    local subsys_dir deploy_after depl_by_deps
    depl_by_deps=()
    for subsys_dir in "${subsys_dirs[@]}"; do
        deploy_after=$(spec_var /subsys/deploy_after "$subsys_dir") || true
        depl_by_deps+=("${deploy_after:--} $(basename "$subsys_dir")")
    done

    local deployments
    old_IFS=$IFS
    IFS=$'\n'
    deployments=($(sort $reverse_arg -s -k 1,2 <<<"${depl_by_deps[*]}" | cut -d' ' -f2-))
    IFS=$old_IFS

    local depl_name
    for depl_name in "${deployments[@]}"; do
        "$cmd" "$depl_name" "$@"
    done
}

function assert_subsys_name() {
    local subsys=$1
    if [ ! -d "$BASE_DIR/deployments/$subsys" ]; then
        echo "${RED}ERROR:$RESET no such $project_name subsys: '$subsys'."
        return 1
    fi
    return 0
}

function converge_deployment() {
    local depl_name=$1; shift

    echo -e "\n${BLUE}Converging the $BOLD'$depl_name'$RESET deployment.\n"

    SUBSYS_DIR=$BASE_DIR/deployments/$depl_name
    eval "$(env_exports)"
    upload_stemcell

    assert_subsys bosh-deployment

    set -e

    fetch_input_resources
    "read_$(spec_var /subsys/type)_spec"

    local subsys_state_dir=$(state_dir)
    mkdir -p "$subsys_state_dir"

    restrict_permissions "$subsys_state_dir/depl-creds.yml"
    bosh_ro_invoke interpolate > "$subsys_state_dir/depl-manifest.yml"

    run_hook_once pre-deploy "$SUBSYS_DIR/pre-deploy-once.sh"
    run_hook "$SUBSYS_DIR/pre-deploy.sh"

    bosh_rw_invoke deploy "$@"

    run_hook_once post-deploy "$SUBSYS_DIR/post-deploy-once.sh"
    run_hook "$SUBSYS_DIR/post-deploy.sh"
}

function delete_deployment() {
    local subsys_name=$1; shift

    echo -e "\n${BLUE}Deleting the $BOLD'$subsys_name'$RESET deployment.\n"

    export SUBSYS_DIR=$BASE_DIR/deployments/$subsys_name
    eval "$(env_exports)"

    run_hook "$SUBSYS_DIR/pre-delete.sh"

    bosh delete-deployment "$@"

    rm -f "$(state_dir)"/{pre,post}-deploy-hook.yml
}

function restrict_permissions() {
    local filename=$1

    >> "$filename"
    chmod 600 "$filename"
}

function internal_ip() {
    internal_ip_hook
}

function external_ip() {
    external_ip_hook
}

function gbe_up() {
    setup_bbl v3.2.6
    setup_terraform 0.9.11
    setup_bosh_cli 2.0.45
    setup_dnscontrol 0.2.3
    setup_cf_cli 6.33.1

    assert_utilities ruby "to render ERB templates locally"

    export SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT
    create_env

    if [ -f ~/.ssh/known_hosts ]; then
        ssh-keygen -f ~/.ssh/known_hosts -R "$(jumpbox_ip)"
    fi
    ssh-keyscan -t ecdsa "$(jumpbox_ip)" 2> /dev/null \
        >> ~/.ssh/known_hosts

    ensure_reachability
    setup_firewall

    alias_env
}

function alias_env() {
    eval "$(env_exports)"
    echo -e "\n${BLUE}Aliasing the created BOSH environment to ${BOLD}'$BOSH_ENVIRONMENT'$RESET\n"

    bosh -e "$(internal_ip)" alias-env "$BOSH_ENVIRONMENT"
}

function create_env() {

    # Assert subsystem is a bosh-environment
    assert_subsys bosh-environment

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    "read_$(spec_var /subsys/type)_spec"
    mkdir -p "$(state_dir "$GBE_ENVIRONMENT")"


    pre_create_env_hook


    if ! has_dns_enabled; then
        echo -e "\n${BLUE}Skipping ${BOLD}dnscontrol push$RESET, as the '$DNS_CREDS_FILE' file is absent\n"
    else
        echo -e "\n${BLUE}Running ${BOLD}dnscontrol push$RESET to converge the external DNS zone\n"
        push_dns_config
    fi


    echo -e "\n${BLUE}Running ${BOLD}bosh create-env$RESET to create the BOSH environment\n"

    infra_bosh_ro_invoke interpolate > "$(state_dir "$GBE_ENVIRONMENT")/depl-manifest.yml"

    export BOSH_LOG_LEVEL=DEBUG
    export BOSH_LOG_PATH=$(state_dir "$GBE_ENVIRONMENT")/bosh-create-env.log
    infra_bosh_rw_invoke create-env


    post_create_env_hook
}

function delete_env() {
    export SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT

    # Assert subsystem is a bosh-environment
    assert_subsys bosh-environment

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    read_$(spec_var /subsys/type)_spec
    mkdir -p "$(state_dir "$GBE_ENVIRONMENT")"


    infra_bosh_ro_invoke interpolate > "$(state_dir "$GBE_ENVIRONMENT")/depl-manifest.yml"

    echo -e "\n${BLUE}Logging out from credhub and closing SSH tunnel$RESET\n"

    if which credhub > /dev/null; then
        credhub logout
    fi
    stop_tunnel
    unset BOSH_ALL_PROXY


    if [ ! -e "$(state_dir "$GBE_ENVIRONMENT")/depl-creds.yml" ]; then
        echo -e "\n${BLUE}Skipping ${BOLD}bosh delete-env$RESET, as the 'state/$GBE_ENVIRONMENT/depl-creds.yml' file is absent\n"
    else
        echo -e "\n${BLUE}Running ${BOLD}bosh delete-env$RESET to destroy the BOSH environment\n"
        infra_bosh_rw_invoke delete-env
        rm -vf "$(state_dir "$GBE_ENVIRONMENT")/depl-creds.yml"
    fi

    rm -f "$BASE_DIR"/state/*/{pre,post}-deploy-hook.yml

    if [ ! -e "$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key" ]; then
        echo -e "\n${BLUE}Skipping ${BOLD}SSH key removal$RESET, as it is absent\n"
    else
        echo -e "\n${BLUE}Removing ${BOLD}SSH key$RESET from SSH Agent\n"
        ssh-keygen -y -f "$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key" > "$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key.pub"
        if ssh-add -L | grep -qF "$(cat "$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key.pub")"; then
            ssh-add -d "$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key.pub"
        fi
        rm -vf "$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key" "$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key.pub"
        ssh-keygen -f ~/.ssh/known_hosts -R "$(jumpbox_ip)"
    fi


    post_delete_env_hook "$@"
}

# GBE_ENVIRONMENT=${GBE_ENVIRONMENT:-gcp-env}
GBE_ENVIRONMENT=${GBE_ENVIRONMENT:-ddbox-env}

function load_env_flavor_hooks() {
    setup_bosh_cli 2.0.45 >&2

    local gbe_env_flavor=$(spec_var /infra_vars/iaas "$BASE_DIR/$GBE_ENVIRONMENT")

    source "$BASE_DIR/lib/envs-flavors/$gbe_env_flavor/infra-hooks.inc.bash"
}
load_env_flavor_hooks

case $1 in
    env)        env_exports ;;
    bbl)        setup_bbl v3.2.6 ;;
    terraform)  setup_terraform 0.9.11 ;;
    bosh)       setup_bosh_cli 2.0.45 ;;
    dnscontrol) setup_dnscontrol 0.2.3 ;;
    credhub)
        setup_credhub_cli 1.5.3
        ensure_reachability
        credhub_login
        ;;
    cf)         setup_cf_cli 6.33.1 ;;
    gcp)
        shift
        if [[ $# -ne 2 ]]; then
            gcp_usage
            exit 2
        fi
        setup_gcp "$@"
        ;;
    up)
        gbe_up ;;
    alias)
        alias_env ;;
    ip)
        jumpbox_ip | cat ;;
    down)
        shift
        delete_env "$@"
        ;;
    firewall)   setup_firewall ;;
    tunnel)
        shift
        case $1 in
            start)  start_tunnel  ;;
            stop)   stop_tunnel   ;;
            status) tunnel_status ;;
            logs)   tunnel_logs   ;;
            *)      tunnel_usage  ;;
        esac
        ;;
    routes)
        add_routes ;;
    dns)
        shift
        verb=$1
        case $verb in
            preview)    preview_dns_config ;;
            push)       push_dns_config ;;
            *)          dns_usage ;;
        esac
        ;;
    ssh)
        shift
        ssh_jumpbox "$@"
        ;;
    update)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                -y)
                    non_interactive=yes ;;
                cloud-config)
                    shift
                    ensure_reachability
                    update_config cloud ${non_interactive:+"-n"} "$@"
                    break ;;
                runtime-config)
                    shift
                    ensure_reachability
                    update_config runtime ${non_interactive:+"-n"} "$@"
                    break ;;
                *)
                    update_usage
                    break ;;
            esac
            shift
        done
        ;;
    converge)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                -h)
                    converge_usage
                    break ;;
                -y)
                    non_interactive=yes ;;
                "")
                    gbe_up
                    break ;;
                list)
                    list_deployments
                    break ;;
                all)
                    ensure_reachability
                    upload_compiled_releases
                    update_config cloud -n
                    update_config runtime -n
                    list_deployments
                    each_deployment converge_deployment -n
                    break ;;
                deployments)
                    ensure_reachability
                    update_config cloud -n
                    update_config runtime -n
                    list_deployments
                    each_deployment converge_deployment -n
                    break ;;
                *)
                    assert_subsys_name "$1" || ( converge_usage && exit 2 )
                    ensure_reachability
                    converge_deployment "$1" ${non_interactive:+"-n"} ;;
            esac
            shift
        done
        ;;
    recreate)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                -h)
                    recreate_usage
                    break ;;
                -y)
                    non_interactive=yes ;;
                all)
                    ensure_reachability
                    list_deployments
                    each_deployment converge_deployment -n --recreate --fix --canaries=0
                    break ;;
                *)
                    assert_subsys_name "$1" || ( recreate_usage && exit 2 )
                    converge_deployment "$1" ${non_interactive:+"-n"} --recreate --fix --canaries=0 ;;
            esac
            shift
        done
        ;;
    delete)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                ""|-h)
                    delete_usage
                    break ;;
                -y)
                    non_interactive=yes ;;
                list)
                    list_deployments --reverse
                    break ;;
                all)
                    shift
                    ensure_reachability
                    list_deployments --reverse
                    each_deployment --reverse delete_deployment -n "$@"
                    break ;;
                *)
                    assert_subsys_name "$1" || ( delete_usage && exit 2 )
                    ensure_reachability
                    delete_deployment "$1" ${non_interactive:+"-n"} ;;
            esac
            shift
        done
        ;;
    export)
        shift
        case $1 in
            -h)
                export_usage ;;
            *)
                ensure_reachability
                export_releases "$@" ;;
        esac
        ;;
    import)
        shift
        case $1 in
            -h)
                import_usage ;;
            *)
                ensure_reachability
                upload_compiled_releases "$@" ;;
        esac
        ;;
    cleanup)
        shift
        cleanup_compiled_releases "$@";;
    *)
        usage; exit 2 ;;
esac

# Local Variables:
# indent-tabs-mode: nil
# End:
