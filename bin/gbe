#!/usr/bin/env bash

set -o pipefail

BASE_DIR=$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")
readonly BASE_DIR

# White-labeling settings
SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")
project_name=GBE
project_desc="Gstack BOSH Environment"

if ! echo "$PATH" | tr : '\n' | grep -q "^$BASE_DIR/bin$"; then
    # update PATH is not already done by direnv
    PATH=$BASE_DIR/bin:$PATH
fi

source "$BASE_DIR/lib/gbe/colors.inc.bash"
source "$BASE_DIR/lib/gbe/spec.inc.bash"
source "$BASE_DIR/lib/gbe/tunnel.inc.bash"
source "$BASE_DIR/lib/gbe/compiled-releases.inc.bash"
source "$BASE_DIR/lib/gbe/dns.inc.bash"
source "$BASE_DIR/lib/gbe/external-utilities.inc.bash"
source "$BASE_DIR/lib/gbe/hooks.inc.bash"

function pushd() {
    command pushd "$@" > /dev/null || exit 115
}

function popd() {
    command popd "$@" > /dev/null
}

function fatal() {
    echo "$@" >&2
    exit 1
}

function platform() {
    local system
    # shellcheck disable=SC2018,SC2019
    system=$(uname -s | tr A-Z a-z)
    if [[ $system == darwin || $system == linux ]]; then
        echo "$system"
    else
        fatal "${RED}ERROR:$RESET unsupported platform: '$system'. Aborting."
    fi
}

function env_usage() {
    local b=$BOLD
    local u=$UNDERLINE
    local rst=$RESET
    local bash_usage="source /dev/stdin <<< \"\$($0 env)\""
    local zsh_usage="source <\"\$(./bin/$SCRIPT_NAME env)\""
    echo
    local shell_name=$(basename "$SHELL" | tr '[:upper:]' '[:lower:]')
    case $shell_name in
        bash|sh)    usage="$b${u}$bash_usage$rst" ;;
        zsh)        usage="$b${u}$zsh_usage$rst" ;;
        *)          usage="$b${u}$zsh_usage$rst or $b${u}$bash_usage$rst" ;;
    esac
    echo "# Usage: run $usage in your $shell_name shell."
    echo
    echo "# Hint: see the actual environment variables exports" \
        "with $b${u}$SCRIPT_NAME env | cat$rst"
    echo
}

function env_exports() {
    if [[ -t 1 ]]; then
        # When running in a terminal
        env_usage
        return
    fi

    echo "export PATH=$PATH"

    local env_creds=$(state_dir "$GBE_ENVIRONMENT")/depl-creds.yml
    if [[ ! -f "$env_creds" ]]; then
        return
    fi

    function env_creds_var() {
        local path=$1
        bosh int "$env_creds" --path "$path"
    }

    env_exports_hook
    local ca_cert admin_password jumpbox_private_key env_alias depl_name
    ca_cert=$(env_creds_var /default_ca/ca)
    admin_password=$(env_creds_var /admin_password)
    jumpbox_private_key=$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key
    env_alias=$(spec_var --required /infra_vars/alias "$BASE_DIR/$GBE_ENVIRONMENT")
    echo "export BOSH_CA_CERT=\"$ca_cert\""
    echo "export BOSH_CLIENT=admin"
    echo "export BOSH_CLIENT_SECRET=\"$admin_password\""
    echo "export BOSH_GW_PRIVATE_KEY=\"$jumpbox_private_key\""
    echo "export BOSH_ENVIRONMENT=\"$env_alias\""
    if [[ -n $SUBSYS_DIR ]]; then
        subsys_type=$(spec_var --required /subsys/type)
        if [[ $subsys_type == bosh-deployment ]]; then
            depl_name=$(spec_var --required /deployment_vars/deployment_name)
            echo "export BOSH_DEPLOYMENT=\"$depl_name\""
        fi
    fi
}

function credhub_login() {
    local creds=$(state_dir "$GBE_ENVIRONMENT")/depl-creds.yml

    if [[ ! -f "$creds" || ! -f "$(state_dir "$GBE_ENVIRONMENT")/bbl-state.json" ]]; then
        return
    fi

    export CREDHUB_SERVER=https://$(internal_ip):8844
    export CREDHUB_CA_CERT=$(state_dir "$GBE_ENVIRONMENT")/credhub_CAs.pem
    (
        bosh int "$creds" --path /credhub_ca/certificate
        bosh int "$creds" --path /default_ca/certificate
    ) > "$CREDHUB_CA_CERT"

    export https_proxy=socks5://127.0.0.1:5000

    local credhub_username=credhub-cli
    local credhub_password=$(bosh int "$creds" --path /credhub_cli_password)

    credhub login \
        --username "$credhub_username" \
        --password "$credhub_password"
}

function setup_gcp() {
    local service_account_name=$1
    local project_id=$2

    local service_account_key=$BASE_DIR/$GBE_ENVIRONMENT/conf/gcp-service-account.key.json
    if [[ -f $service_account_key ]]; then
        echo -e "INFO: the 'gcp-service-account.key.json' credentials file" \
            "already exists in directory '$BASE_DIR/$GBE_ENVIRONMENT/conf/'. ${BLUE}Skipping${RESET}."
        return 0
    fi

    assert_utilities gcloud "to setup GCP credentials"

    echo -e "${BLUE}Setting ${BOLD}GCP credentials$RESET" \
        "for service account '$service_account_name' and project '$project_id'"

    local initial_errexit=$(tr -Cd e <<< "$-")
    if [[ -z $initial_errexit ]]; then set -e; fi
    gcloud iam service-accounts create "$service_account_name"
    gcloud iam service-accounts keys create \
        --iam-account="${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        "$service_account_key"
    chmod 600 "$service_account_key"
    gcloud projects add-iam-policy-binding "$project_id" \
        --member="serviceAccount:${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        --role='roles/editor'
    if [[ -z $initial_errexit ]]; then set +e; fi

    local temp_file=$(mktemp)
    sed -e "s/^  project_id:.*$/project_id: $project_id/" "$BASE_DIR/$GBE_ENVIRONMENT/conf/spec.yml" > "$temp_file"
    cp "$temp_file" "$BASE_DIR/$GBE_ENVIRONMENT/conf/spec.yml"
    rm "$temp_file"

    echo -e "$GREEN${BOLD}OK$RESET"
}

function usage() {
    echo "$project_name ($project_desc) CLI"
    echo "  $BOLD${MAGENTA}SETUP:$RESET"
    echo "  env         Sourceable envrionment variables for CLI clients"
    echo "  gcp         Configures the Google Cloud credentials"
    echo "  firewall    Configures the Google Cloud firewall rules"
    echo "  tunnel      Creates a SSH tunnel to the BOSH director, acting as a SOCKS5 proxy"
    echo
    echo "  $BOLD${MAGENTA}BOSH ENVIRONMENT:$RESET"
    echo "  up          Converges the base infrastructure environment towards its desired state"
    echo "  down        Destroys the base infrastructure environment"
    echo "  ip          Outputs the main exernal IP address of the environment"
    echo "  dns         Converge DNS towards the expected DNSControl configuration"
    echo "  ssh         Logs into the BOSH environment VM with SSH"
    echo
    echo "  $BOLD${MAGENTA}MANAGED SUBSYSTEMS:$RESET"
    echo "  update      Updates the cloud config or the runtime config"
    echo "  converge    Converges one or many subsystems towards their desired states"
    echo "  recreate    Recreates one or many subsystems towards their desired states"
    echo "  delete      Deletes one or many subsystems"
    echo
    echo "  $BOLD${MAGENTA}UTILITIES SETUP:$RESET"
    echo "  bbl         Installs locally the supported version of BOSH-Bootloader CLI"
    echo "  terraform   Installs locally the supported version of Terraform CLI"
    echo "  bosh        Installs locally the supported version of BOSH CLI"
    echo "  dnscontrol  Installs locally the supported version of DNSControl CLI"
    echo "  cf          Installs locally the supported version of Cloud Foundry CLI"
    echo
    echo "  $BOLD${MAGENTA}COMPILED RELEASES:$RESET"
    echo "  export      Popoulate the local cache with all compiled releases"
    echo "  import      Import all compiled releases from the cache to the BOSH director"
    echo "  cleanup     Delete stale compiled releases from the cache"
    echo
}

function gcp_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}gcp$noul  <service-account-name>  <project-id>"
    echo
    echo "    <service-account-name>   A name for the service account to be created"
    echo "    <project-id>             The identifier of your GCP project, like 'alpha-sandbox-717101'"
    echo
    echo "Sets the necessary GCP credentials for $project_name:"
    echo "    1. Create the designated service account in GCP."
    echo "    2. Create a service account key in 'conf/gcp-service-account.key.json'."
    echo "    3. Grant to the service account an 'editor' role on the project."
    echo
}

function up_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}up$noul"
    echo
    echo "Creates or converges the BOSH environment VM with 'bosh create-env'."
    echo
    echo "Before the environment is converged, the required utilities are"
    echo "downloaded, if absent."
    echo
    echo "After the environment is converged, a SSH tunnel is started, enabling"
    echo "access the BOSH director. Then the BOSH environnment is referenced in the"
    echo "BOSH CLI config. A use of $ul$SCRIPT_NAME env$noul might be necessary though."
    echo
    echo "Any previously trusted SSH key (from the '~/.ssh/known_hosts') is replaced"
    echo "before the tunnel is started, in case it has changed, to avoid connection"
    echo "issues or hassle."
    echo
}

function down_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}down$noul  [-k]"
    echo
    echo "Destroys the base infrastructure environment, including the related"
    echo "BOSH director."
    echo
    echo "    -k"
    echo "        Keep some allocated resources on the automated infrastructure,"
    echo "        which is useful to preserve the allocated public IP address for"
    echo "        the BOSH director."
    echo
}

function dns_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  preview"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  push"
    echo
    echo "Dry-run the DNS congergence with '${b}dnscontrol preview$rst' or"
    echo "actually converge the DNS with '${b}dnscontrol push$rst'."
    echo
}

function tunnel_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  start"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  stop"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  status"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  logs"
    echo
    echo "Start or stop a SOCKS5 compatible SSH tunnel, or get its status, or"
    echo "obtain any logs produced. This tunnel is necessary in order to access"
    echo "the BOSH director, and keep it away from being exposed to the entire"
    echo "Internet, protected behind firewall rules."
    echo
    echo "Environment variables might then need to be be refreshed. Run ${ul}gbe env$noul"
    echo "for more details."
    echo
}

function update_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}update$noul  [-y]  [(cloud-config | runtime-config)...]"
    echo
    echo "Updates the cloud config or the runtime config in BOSH director."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input."
    echo
    echo "See also:"
    echo "  ${ul}https://bosh.io/docs/cloud-config.html$noul"
    echo "  ${ul}https://bosh.io/docs/runtime-config.html$noul"
    echo
}

function converge_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  [-y]  <subsys-name>..."
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  all"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  list"
    echo
    echo "    <subsys-name>   The name of a subsys to converge."
    echo
    echo "Converges one or all subsystems towards their desired states, or"
    echo "converge the base infrastructure environment if no subsystem is"
    echo "specified."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any"
    echo "user input. Both cloud config and runtime config will be updated,"
    echo "and all subsystems will be converged."
    echo
    echo "When specifying ${b}list$rst, the list of subsystems to converge is"
    echo "displayed, in the order ${b}gbe converge all$rst would treat them."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input."
    echo
    echo "    --manifest"
    echo "        Don't actually deploy. Only render deployment manifest"
    echo "        and generate credentials. Don't run BOSH or any hooks."
    echo
    echo "    --dry-run"
    echo "        Don't actually deploy. Only render deployment manifest,"
    echo "        generate credentials, and run BOSH in dry-run mode. In this"
    echo "        mode, the director downloads any necessary BOSH releases."
    echo
}

function recreate_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  [-y]  <subsys-name>..."
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  all"
    echo
    echo "    <subsys-name>   The name of a subsys to recreate."
    echo
    echo "Recreates one or all subsystems towards their desired states."
    echo "This command is supposed to recreate subsystems that were"
    echo "previously deployed with no errors."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any"
    echo "user input."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function delete_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  [-y] [-f]  <subsys-name>..."
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  all [-f]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  list"
    echo
    echo "    <subsys-name>   The name of a subsys to delete."
    echo
    echo "Deletes one or all subsystems. This ${b}delete$rst operation is"
    echo "VERY DESTRUCTIVE."
    echo
    echo "When destroying ${b}all$rst subsystems, the deletion will not ask"
    echo "for any user input."
    echo
    echo "When specifying ${b}list$rst, the list of subsystems to delete is"
    echo "displayed, in the order ${b}gbe delete all$rst would treat them."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input. NOT RECOMMENDED."
    echo
    echo "    -f"
    echo "        Ignore errors. SHOULD BE USED WITH CAUTION, as a last resort"
    echo "        only."
    echo
}

function export_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}export$noul  [<subsys-name>]"
    echo
    echo "    <subsys-name>   The name of a subsys of type 'bosh-deployment'."
    echo
    echo "Exports all compiled releases from the BOSH Director, going through"
    echo "all deployments currently managed by the BOSH director, as desribed by"
    echo "all subsystems."
    echo
    echo "When specifying a subsys name, the set of exported releases is"
    echo "restricted to those related to the specified subsystem. This"
    echo "subsystem must be of type 'bosh-deployment' and the related"
    echo "BOSH deployment must exist in the BOSH director."
    echo
}

function import_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}import$noul  [<subsys-name>]"
    echo
    echo "    <subsys-name>   The name of a subsys of type 'bosh-deployment'."
    echo
    echo "Imports all compiled releases going through each deployments"
    echo "currently managed by the BOSH director."
    echo
    echo "When specifying a subsys name, the exported BOSH releases are those"
    echo "that are necessary to the BOSH deployment that the subsys describes."
    echo "This subsys must be of type 'bosh-deployment' and there must be a"
    echo "subfolder of that name in the '.cache/compiled-releases/' directory."
    echo
}

function setup_firewall() {
    setup_firewall_hook
}

function ensure_reachability() {
    ensure_reachability_hook
}

function add_routes() {
    local network_cidr platform netstat_pattern sudo_cmd
    network_cidr=$(spec_var --required /deployment_vars/routable_network_cidr "$BASE_DIR/$GBE_ENVIRONMENT")
    platform=$(platform)
    case $platform in
        darwin) netstat_pattern=$(sed -E -e 's`(\.0)+(/[0-9]+)?$`\2`' <<< "$network_cidr") ;;
        linux)  netstat_pattern=$(sed -r -e 's`/[0-9]+$``' <<< "$network_cidr") ;;
    esac
    if netstat -nr | awk '{print $1}' | grep -qE "^${netstat_pattern//./\\.}\$"; then
        return
    fi
    echo -e "\n${BLUE}Adding ${BOLD}route$RESET to reach the BOSH director and deployed nodes\n"
    sudo_cmd=(sudo -p "[${MAGENTA}${UNDERLINE}local$NOUNDERLINE ${BOLD}sudo$RESET (on %h)] password for %u: ")
    case $platform in
        darwin) "${sudo_cmd[@]}" route add -net "$network_cidr"    $(internal_ip) ;;
        linux)  "${sudo_cmd[@]}" route add -net "$network_cidr" gw $(internal_ip) ;;
    esac
}

function update_config() {
    local cfg_type=$1; shift # 'cloud' or 'runtime'

    SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT/${cfg_type}-config
    eval "$(env_exports)"

    # Assert subsystem is a BOSH config
    # (meaning: cloud config or runtime config)
    assert_subsys bosh-config

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    local subsys_state_dir subsys_type
    subsys_state_dir=$(state_dir)
    mkdir -p "$subsys_state_dir"
    subsys_type=$(spec_var --required /subsys/type)
    "read_${subsys_type}_spec"


    echo -e "\n${BLUE}Updating $BOLD$cfg_type config$RESET in BOSH director.\n"

    bosh interpolate "$MAIN_CONFIG_FILE" \
        "${OPERATIONS_ARGUMENTS[@]}" \
        --vars-file <(spec_var /config_vars) \
        --vars-file <(imported_vars) \
        > "$subsys_state_dir/${cfg_type}-config.yml"
    [[ -x $(which humanize-manifest) ]] && \
        humanize-manifest "$subsys_state_dir/${cfg_type}-config.yml" \
            > "$subsys_state_dir/${cfg_type}-config-humanized.yml"

    if [[ ! -s $subsys_state_dir/${cfg_type}-config.yml ]]; then
        echo "${cfg_type} config file is empty." \
                "${BLUE}Skipping$RESET update." \
            | awk '{print toupper(substr($0,1,1)) substr($0,2)}'
        exit 0
    fi
    bosh update-${cfg_type}-config "$subsys_state_dir/${cfg_type}-config.yml" "$@"
}

function upload_stemcell() {
    local stemcell_name stemcell_version stemcell_sha1

    stemcell_name=$(spec_var /deployment_vars/stemcell_name)
    stemcell_version=$(spec_var /deployment_vars/stemcell_version)
    stemcell_sha1=$(spec_var /deployment_vars/stemcell_sha1)

    if [[ -z $stemcell_name || -z $stemcell_version || -z $stemcell_sha1 ]]; then
        return
    fi

    bosh upload-stemcell \
        --name "$stemcell_name" \
        --version "$stemcell_version" \
        --sha1 "$stemcell_sha1" \
        "https://bosh.io/d/stemcells/$stemcell_name?v=$stemcell_version"
}

function list_deployments() {
    echo -e "\n$BLUE${BOLD}Affected subsystems$RESET in order:\n"
    each_deployment "$@" print_deployment_name
    echo
}

function print_deployment_name() {
    local depl_name=$1
    echo "  - $depl_name"
}

function each_deployment() {
    local reverse_arg cmd
    if [[ x$1 == x-r || x$1 == x--reverse ]]; then
        reverse_arg=$1; shift
    fi
    cmd=$1; shift

    local old_IFS subsys_dirs
    old_IFS=$IFS
    IFS=$'\n'
    subsys_dirs=($(find "$BASE_DIR/deployments" -mindepth 1 -maxdepth 1 \
            -type d \! -name 'zzz-*' \
            -print))
    IFS=$old_IFS

    local subsys_dir deploy_after depl_by_deps
    depl_by_deps=()
    for subsys_dir in "${subsys_dirs[@]}"; do
        deploy_after=$(spec_var /subsys/deploy_after "$subsys_dir")
        depl_by_deps+=("${deploy_after:-"-"} $(basename "$subsys_dir")")
    done

    local deployments
    old_IFS=$IFS
    IFS=$'\n'
    deployments=($(sort $reverse_arg -s -k 1,2 <<< "${depl_by_deps[*]}" | cut -d' ' -f2-))
    IFS=$old_IFS

    local depl_name
    for depl_name in "${deployments[@]}"; do
        "$cmd" "$depl_name" "$@"
    done
}

function assert_subsys_name() {
    local subsys=$1
    if [[ ! -d $BASE_DIR/deployments/$subsys ]]; then
        echo "${RED}ERROR:$RESET no such $project_name subsys: '$subsys'."
        return 1
    fi
    return 0
}

function converge_deployment() {
    local depl_name=$1; shift

    local manifest dry_run offline
    if [[ $@ == *--manifest* ]]; then manifest_only=yes; fi
    if [[ $@ == *--dry-run* ]]; then  dry_run=yes; fi
    if [[ $@ == *--offline* ]]; then  offline=yes; fi

    local action="Converging"
    if [[ -n $manifest_only ]]; then
        action="Rendering deployment manifest and generating credentials for"
    elif [[ -n $dry_run ]]; then
        action="Converging (dry run)"
    fi

    echo -e "\n${BLUE}$action the $BOLD'$depl_name'$RESET subsystem.\n"

    SUBSYS_DIR=$BASE_DIR/deployments/$depl_name
    eval "$(env_exports)"
    upload_stemcell

    assert_subsys bosh-deployment

    set -e

    fetch_input_resources ${offline:+"--offline"}
    local subsys_state_dir subsys_type
    subsys_state_dir=$(state_dir)
    mkdir -p "$subsys_state_dir"
    subsys_type=$(spec_var --required /subsys/type)
    "read_${subsys_type}_spec"

    restrict_permissions "$subsys_state_dir/depl-creds.yml"
    bosh_ro_invoke interpolate > "$subsys_state_dir/depl-manifest.yml"
    [[ -x $(which humanize-manifest) ]] && \
        humanize-manifest "$subsys_state_dir/depl-manifest.yml" \
            > "$subsys_state_dir/depl-manifest-humanized.yml"

    if [[ -n $manifest_only || -n $offline ]]; then
        bosh_rw_invoke interpolate > /dev/null # generate credentails if necessary
        echo -e "\nBOSH deployment manifest is rendered (and credentials" \
            "generated) in '${subsys_state_dir/#$PWD/.}' directory.\n"
        return
    fi

    if [[ -z $dry_run ]]; then
        run_hook_once pre-deploy "$SUBSYS_DIR/pre-deploy-once.sh"
        run_hook "$SUBSYS_DIR/pre-deploy.sh"
    fi

    bosh_rw_invoke deploy "$@"

    if [[ -z $dry_run ]]; then
        run_hook_once post-deploy "$SUBSYS_DIR/post-deploy-once.sh"
        run_hook "$SUBSYS_DIR/post-deploy.sh"
    fi
}

function delete_deployment() {
    local subsys_name=$1; shift

    local ignore_errors
    if [[ $@ == *--force* ]]; then ignore_errors=yes; fi

    echo -e "\n${BLUE}Deleting the $BOLD'$subsys_name'$RESET subsystem.\n"

    SUBSYS_DIR=$BASE_DIR/deployments/$subsys_name
    eval "$(env_exports)"

    assert_subsys bosh-deployment

    if [[ -z $ignore_errors ]]; then
        set -e
    fi

    run_hook "$SUBSYS_DIR/pre-delete.sh"

    bosh delete-deployment "$@"

    rm -f "$(state_dir)"/{pre,post}-deploy-hook.yml
}

function restrict_permissions() {
    local filename=$1

    >> "$filename"
    chmod 600 "$filename"
}

function internal_ip() {
    internal_ip_hook
}

function external_ip() {
    external_ip_hook
}

function gbe_up() {
    setup_bbl
    setup_terraform
    setup_bosh_cli
    setup_dnscontrol
    setup_cf_cli

    assert_utilities ruby "to render ERB templates locally"

    SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT
    create_env

    if [[ -f ~/.ssh/known_hosts ]]; then
        ssh-keygen -f ~/.ssh/known_hosts -R "$(jumpbox_ip)"
    fi
    ssh-keyscan -t ecdsa "$(jumpbox_ip)" 2> /dev/null \
        >> ~/.ssh/known_hosts

    # This workaround avoids the "Too many authentication failures for
    # jumpbox" error when ensuring reachability below.
    ssh-add -D

    ensure_reachability
    setup_firewall

    alias_env
}

function alias_env() {
    eval "$(env_exports)"
    echo -e "\n${BLUE}Aliasing the created BOSH environment to ${BOLD}'$BOSH_ENVIRONMENT'$RESET\n"

    bosh -e "$(internal_ip)" alias-env "$BOSH_ENVIRONMENT"
}

function create_env() {

    # Assert subsystem is a bosh-environment
    assert_subsys bosh-environment

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    local env_state_dir subsys_type
    env_state_dir=$(state_dir "$GBE_ENVIRONMENT")
    mkdir -p "$env_state_dir"
    subsys_type=$(spec_var --required /subsys/type)
    "read_${subsys_type}_spec"


    pre_create_env_hook


    if ! has_dns_enabled; then
        echo -e "\n${BLUE}Skipping ${BOLD}dnscontrol push$RESET, as the '$DNS_CREDS_FILE' file is absent\n"
    else
        echo -e "\n${BLUE}Running ${BOLD}dnscontrol push$RESET to converge the external DNS zone\n"
        push_dns_config
    fi


    echo -e "\n${BLUE}Running ${BOLD}bosh create-env$RESET to create the BOSH environment\n"

    infra_bosh_ro_invoke interpolate > "$env_state_dir/depl-manifest.yml"
    [[ -x $(which humanize-manifest) ]] && \
        humanize-manifest "$env_state_dir/depl-manifest.yml" \
            > "$env_state_dir/depl-manifest-humanized.yml"

    if [[ -n $GBE_DEBUG_LEVEL ]]; then
        # This is just an example of how we can have verbose logs using the
        # GBE_DEBUG_LEVEL environment variable.
        export BOSH_LOG_LEVEL=DEBUG
        export BOSH_LOG_PATH=$env_state_dir/bosh-create-env.log
    fi
    infra_bosh_rw_invoke create-env


    post_create_env_hook
}

function delete_env() {
    SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT

    # Assert subsystem is a bosh-environment
    assert_subsys bosh-environment

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    local subsys_state_dir subsys_type
    subsys_state_dir=$(state_dir "$GBE_ENVIRONMENT")
    mkdir -p "$subsys_state_dir"
    subsys_type=$(spec_var --required /subsys/type)
    "read_${subsys_type}_spec"


    infra_bosh_ro_invoke interpolate > "$subsys_state_dir/depl-manifest.yml"
    [[ -x $(which humanize-manifest) ]] && \
        humanize-manifest "$subsys_state_dir/depl-manifest.yml" \
            > "$subsys_state_dir/depl-manifest-humanized.yml"

    echo -e "\n${BLUE}Logging out from credhub and closing SSH tunnel$RESET\n"

    if which credhub > /dev/null; then
        credhub logout
    fi
    cease_reachability_hook


    if [[ ! -e $subsys_state_dir/depl-creds.yml ]]; then
        echo -e "\n${BLUE}Skipping ${BOLD}bosh delete-env$RESET, as the 'state/$GBE_ENVIRONMENT/depl-creds.yml' file is absent\n"
    else
        echo -e "\n${BLUE}Running ${BOLD}bosh delete-env$RESET to destroy the BOSH environment\n"
        infra_bosh_rw_invoke delete-env
        rm -vf "$subsys_state_dir/depl-creds.yml"
    fi

    rm -f "$BASE_DIR"/state/*/{pre,post}-deploy-hook.yml

    if [[ ! -e $subsys_state_dir/jumpbox.key ]]; then
        echo -e "\n${BLUE}Skipping ${BOLD}SSH key removal$RESET, as it is absent\n"
    else
        echo -e "\n${BLUE}Removing ${BOLD}SSH key$RESET from SSH Agent\n"
        ssh-keygen -y -f "$subsys_state_dir/jumpbox.key" > "$subsys_state_dir/jumpbox.key.pub"
        if ssh-add -L | grep -qF "$( < "$subsys_state_dir/jumpbox.key.pub" )"; then
            ssh-add -d "$subsys_state_dir/jumpbox.key.pub"
        fi
        rm -vf "$subsys_state_dir/jumpbox.key" "$subsys_state_dir/jumpbox.key.pub"
        ssh-keygen -f ~/.ssh/known_hosts -R "$(jumpbox_ip)"
    fi


    post_delete_env_hook "$@"
}

# GBE_ENVIRONMENT=${GBE_ENVIRONMENT:-gcp-env}
GBE_ENVIRONMENT=${GBE_ENVIRONMENT:-ddbox-env}

function load_env_flavor_hooks() {
    setup_bosh_cli >&2

    local gbe_env_flavor
    gbe_env_flavor=$(spec_var --required /infra_vars/iaas "$BASE_DIR/$GBE_ENVIRONMENT")

    source "$BASE_DIR/lib/envs-flavors/$gbe_env_flavor/infra-hooks.inc.bash"
}
load_env_flavor_hooks

case $1 in
    env)        env_exports ;;
    bbl)        setup_bbl ;;
    terraform)  setup_terraform ;;
    bosh)       setup_bosh_cli ;;
    dnscontrol) setup_dnscontrol ;;
    credhub)
        setup_credhub_cli
        ensure_reachability
        credhub_login
        ;;
    cf)         setup_cf_cli ;;
    gcp)
        shift
        if [[ $# -ne 2 ]]; then
            gcp_usage
            exit 2
        fi
        setup_gcp "$@"
        ;;
    up)
        gbe_up ;;
    alias)
        alias_env ;;
    ip)
        jumpbox_ip | cat ;;
    bosh-installation)
        assert_utilities jq "to display the BOSH installation path"
        installation_id=$(jq -r .installation_id state/ddbox-env/env-infra-state.json)
        echo "$HOME/.bosh/installations/$installation_id"
        ;;
    down)
        shift
        delete_env "$@"
        ;;
    firewall)   setup_firewall ;;
    tunnel)
        shift
        case $1 in
            start)  start_tunnel  ;;
            stop)   stop_tunnel   ;;
            status) tunnel_status ;;
            logs)   tunnel_logs   ;;
            *)      tunnel_usage  ;;
        esac
        ;;
    routes)
        add_routes ;;
    dns)
        shift
        verb=$1
        case $verb in
            preview)    preview_dns_config ;;
            push)       push_dns_config ;;
            *)          dns_usage ;;
        esac
        ;;
    ssh)
        shift
        ssh_jumpbox "$@"
        ;;
    update)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                -y)
                    non_interactive=yes ;;
                cloud-config)
                    ensure_reachability
                    update_config cloud ${non_interactive:+"-n"}
                    ;;
                runtime-config)
                    ensure_reachability
                    update_config runtime ${non_interactive:+"-n"}
                    ;;
                *)
                    update_usage
                    break ;;
            esac
            shift
        done
        ;;
    converge)
        shift
        if [[ -z $1 ]]; then
            gbe_up
        else
            non_interactive=
            manifest_only=
            dry_run=
            offline=
            while [[ -n $1 ]]; do
                case $1 in
                    -h)
                        converge_usage
                        break ;;
                    -y)         non_interactive=yes ;;
                    --manifest) manifest_only=yes ;;
                    --dry-run)  dry_run=yes ;;
                    --offline)  offline=yes ;;
                    list)
                        list_deployments
                        break ;;
                    all)
                        ensure_reachability
                        upload_compiled_releases
                        update_config cloud -n
                        update_config runtime -n
                        list_deployments
                        each_deployment converge_deployment -n
                        break ;;
                    deployments)
                        ensure_reachability
                        update_config cloud -n
                        update_config runtime -n
                        list_deployments
                        each_deployment converge_deployment -n
                        break ;;
                    *)
                        if ! assert_subsys_name "$1"; then
                            converge_usage; exit 2
                        fi
                        ensure_reachability
                        converge_deployment "$1" \
                            ${non_interactive:+"-n"} \
                            ${manifest_only:+"--manifest"} \
                            ${dry_run:+"--dry-run"} \
                            ${offline:+"--offline"} ;;
                esac
                shift
            done
        fi
        ;;
    recreate)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                -h)
                    recreate_usage
                    break ;;
                -y)
                    non_interactive=yes ;;
                all)
                    ensure_reachability
                    list_deployments
                    each_deployment converge_deployment -n --recreate --fix --canaries=0
                    break ;;
                *)
                    if ! assert_subsys_name "$1"; then
                        recreate_usage; exit 2
                    fi
                    converge_deployment "$1" ${non_interactive:+"-n"} --recreate --fix --canaries=0 ;;
            esac
            shift
        done
        ;;
    delete)
        shift
        non_interactive=
        ignore_errors=
        while [[ -n $1 ]]; do
            case $1 in
                ""|-h)
                    delete_usage
                    break ;;
                -y)
                    non_interactive=yes ;;
                -f)
                    ignore_errors=yes ;;
                list)
                    list_deployments --reverse
                    break ;;
                all)
                    shift
                    ensure_reachability
                    list_deployments --reverse
                    each_deployment --reverse delete_deployment -n ${ignore_errors:+"--force"} "$@"
                    break ;;
                *)
                    if ! assert_subsys_name "$1"; then
                        delete_usage; exit 2
                    fi
                    ensure_reachability
                    delete_deployment "$1" ${non_interactive:+"-n"} ${ignore_errors:+"--force"} ;;
            esac
            shift
        done
        ;;
    export)
        shift
        case $1 in
            -h)
                export_usage ;;
            *)
                ensure_reachability
                export_releases "$@" ;;
        esac
        ;;
    import)
        shift
        case $1 in
            -h)
                import_usage ;;
            *)
                ensure_reachability
                upload_compiled_releases "$@" ;;
        esac
        ;;
    cleanup)
        shift
        cleanup_compiled_releases "$@";;
    *)
        usage; exit 2 ;;
esac

# Local Variables:
# indent-tabs-mode: nil
# End:
