#!/usr/bin/env bash

BASE_DIR=$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")

if ! echo "$PATH" | tr : '\n' | grep -qF "$BASE_DIR/bin"; then
    # update PATH is not already done by direnv
    PATH=$BASE_DIR/bin:$PATH
fi

source "$BASE_DIR/lib/colors.inc.bash"

function pushd() {
    command pushd "$@" > /dev/null
}

function popd() {
    command popd "$@" > /dev/null
}

function fatal() {
    echo "$@" >&2
    exit 1
}

function platform() {
    local system
    # shellcheck disable=SC2018,SC2019
    system=$(uname -s | tr A-Z a-z)
    if [[ $system == darwin || $system == linux ]]; then
        echo "$system"
    else
        fatal "ERROR: unsupported platform: '$system'. Aborting."
    fi
}

function assert_utilities() {
    local utilities=()

    while # NOTE: emulating do-while, see <https://stackoverflow.com/a/27761760>
        utilities+=("$1"); shift
        [ $# -gt 1 ]
    do :; done
    local reason=$1; shift # last argument

    for utility in "${utilities[@]}"; do
        if ! which "$utility" > /dev/null; then
            fatal "ERROR: GBE requires '$utility'${reason:+" $reason"}." \
                "Please install it first. Aborting."
        fi
    done
}

function env_exports() {
    echo "export PATH=$PATH"
}

function setup_bbl() {
    local bbl_version=$1

    if which bbl > /dev/null 2>&1; then
        local existing_bbl_version
        existing_bbl_version=$(bbl --version | head -n 1 | cut -d' ' -f2)
        if [[ $existing_bbl_version =~ ^3\.2\..*$ ]]; then
            return 0
        fi
    fi

    local bbl_bin=$BASE_DIR/bin/bbl
    if [ -f "$bbl_bin" ]; then
        return 0
    fi

    assert_utilities curl "to install bosh-bootloader"

    local bbl_repo=https://github.com/cloudfoundry/bosh-bootloader
    local linux_bin=bbl-${bbl_version}_linux_x86-64
    local darwin_bin=bbl-${bbl_version}_osx

    echo "${BLUE}Installing ${BOLD}bosh-bootloader CLI$RESET $bbl_version as: $bbl_bin"
    local url
    case $(platform) in
        darwin) url=$bbl_repo/releases/download/$bbl_version/$darwin_bin;;
        linux)  url=$bbl_repo/releases/download/$bbl_version/$linux_bin;;
    esac

    curl -sL -o "$bbl_bin" "$url"
    chmod +x "$bbl_bin"
}

function setup_terraform() {
    local tf_version=$1

    if which terraform > /dev/null 2>&1; then
        local existing_tf_version
        existing_tf_version=$(terraform --version | head -n 1 | cut -d' ' -f2)
        if [[ $existing_tf_version =~ ^v0\.9\..*$ ]]; then
            return 0
        fi
    fi

    local tf_bin=$BASE_DIR/bin/terraform
    if [ -f "$tf_bin" ]; then
        return 0
    fi

    assert_utilities curl unzip "to install terraform"

    local base_url=https://releases.hashicorp.com/terraform

    echo -e "${BLUE}Installing ${BOLD}terraform CLI$RESET v$tf_version as: $tf_bin"
    local url
    url=$base_url/$tf_version/terraform_${tf_version}_$(platform)_amd64.zip

    local temp_dir
    temp_dir=$(mktemp -d)
    pushd "$temp_dir"
        curl -sL -o tf.zip "$url"
        unzip tf.zip
        rm tf.zip
        mv terraform "$tf_bin"
        chmod +x "$tf_bin"
    popd
    rm -rf "$temp_dir"
}

function setup_gcp() {
    local service_account_name=$1
    local project_id=$2

    local service_account_key=$BASE_DIR/conf/gcp-service-account.key.json
    if [ -f "$service_account_key" ]; then
        echo -e "INFO: the 'gcp-service-account.key.json' credentials file" \
            "already exists in directory '$BASE_DIR/conf/'. ${BLUE}Skipping${RESET}."
        return 0
    fi

    assert_utilities gcloud "to setup GCP credentials"

    echo -e "${BLUE}Setting ${BOLD}GCP credentials$RESET" \
        "for service account '$service_account_name' and project '$project_id'"

    local had_dash_e
    had_dash_e=$(echo $- | tr -Cd e)
    set -e
    gcloud iam service-accounts create "$service_account_name"
    gcloud iam service-accounts keys create \
        --iam-account="${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        "$service_account_key"
    chmod 600 "$service_account_key"
    gcloud projects add-iam-policy-binding "$project_id" \
        --member="serviceAccount:${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        --role='roles/editor'
    if [ -z "$had_dash_e" ]; then
        set +e
    fi

    local temp_file=$(mktemp)
    sed -e "s/^project_id:.*$/project_id: $project_id/" "$BASE_DIR/conf/env-infra-vars.yml" > "$temp_file"
    cp "$temp_file" "$BASE_DIR/conf/env-infra-vars.yml"
    rm "$temp_file"

    echo -e "$GREEN${BOLD}OK$RESET"
}

function usage() {
    echo "GBE (Gstack BOSH Environment) CLI"
    echo "  $BOLD${MAGENTA}SETUP:$RESET"
    echo "  env         Sourceable envrionment variables for CLI clients"
    echo "  bbl         Installs locally the supported version of Bosh-Bootloader CLI"
    echo "  terraform   Installs locally the supported version of Terraform CLI"
    echo "  gcp         Configures the Google Cloud credentials"
    echo
    echo "  $BOLD${MAGENTA}BOSH ENVIRONMENT:$RESET"
    echo "  up          Creates the BOSH environment VM with 'bosh create-env'"
    echo "  down        Deletes the BOSH environment VM with 'bosh delete-env'"
    echo "  ssh         Logs into the BOSH Environment VM with SSH"
}

function gcp_usage() {
    echo "Usage:"
    echo "  gbe  gcp  ${UNDERLINE}service-account-name$NOUNDERLINE  ${UNDERLINE}project-id$NOUNDERLINE"
    echo
    echo "    ${UNDERLINE}service-account-name$NOUNDERLINE   A name for the service account to be created"
    echo "    ${UNDERLINE}project-id$NOUNDERLINE             The identifier of your GCP project, like 'alpha-sandbox-717101'"
    echo
    echo "Sets the necessary GCP credentials for GBE:"
    echo "    1. Create the designated service account in GCP."
    echo "    2. Create a service account key in 'conf/gcp-service-account.key.json'."
    echo "    3. Grant to the service account an 'editor' role on the project."
}

function update_usage() {
    echo "Usage:"
    echo "  gbe  update  [ cloud-config | runtime-config ]"
    echo
    echo "Updates the BOSH cloud-config or the runtime-config."
}

function converge_usage() {
    echo "Usage:"
    echo "  gbe  converge  [${UNDERLINE}deployment-name${NOUNDERLINE}]"
    echo
    echo "    ${UNDERLINE}deployment-name$NOUNDERLINE   The name of a deployment to converge. Optional."
    echo
    echo "Converges a deployment towards a new desired state,"
    echo "or converge the BOSH environment if no deployment is specified."
}

function source_env() { # shim
    local rel_dir=$1

    pushd "$rel_dir"
    if [ -f .envrc ]; then
        source .envrc
    fi
    popd
}

function bbl_invoke() {
    bbl --state-dir "$BASE_DIR/state" "$@"
}

function setup_firewall() {
    assert_utilities gcloud "to update firewall rules"

    local fw_rule_name
    fw_rule_name=$(bbl_invoke env-id)-bosh-open

    local allowed=icmp
    # Note: the 'gcloud' CLI v165.0.0 doesn't support the shorter syntax with
    #       semicolons, like "icmp; tcp:22,6868,25555". So we revert to the
    #       more verbose syntax here, e.g. "icmp,tcp:22,tcp:6868,tcp:25555".
    for tcp_port in 22 80 443 2222 3306 4443 6868 8080 25555; do
        allowed=$allowed,tcp:$tcp_port
    done

    gcloud compute firewall-rules update "$fw_rule_name" --allow="$allowed"
}

case $1 in
    env)        env_exports ;;
    bbl)        setup_bbl v3.2.6 ;;
    terraform)  setup_terraform 0.9.11 ;;
    gcp)
        shift
        if [[ $# -ne 2 ]]; then
            gcp_usage
            exit 2
        fi
        setup_gcp "$@"
        ;;
    up)
        setup_bbl v3.2.6
        setup_terraform 0.9.11
        pushd "$BASE_DIR"
            source .envrc
            create-env
        popd
        setup_firewall
        ;;
    down)
        pushd "$BASE_DIR"
            source .envrc
            delete-env
        popd
        ;;
    firewall)
        setup_firewall
        ;;
    ssh)
        pushd "$BASE_DIR"
            source .envrc
            jumpbox
        popd
        ;;
    update)
        shift
        case $1 in
            cloud-config|cc)
                pushd "$BASE_DIR/deployments/_cloud-config"
                    source .envrc
                    update-cloud-config
                popd
                ;;
            runtime-config|rc)
                pushd "$BASE_DIR/deployments/_runtime-config"
                    source .envrc
                    update-runtime-config
                popd
                ;;
            *)
                update_usage ;;
        esac
        ;;
    converge)
        shift
        case $1 in
            -h)
                converge_usage ;;
            "")
                create-env ;;
            *)
                depl_name=$1
                pushd "$BASE_DIR/deployments/$depl_name"
                    source .envrc
                    upload-stemcell
                    deploy
                popd
                ;;
        esac
        ;;
    *)          usage; exit 2 ;;
esac

# Local Variables:
# indent-tabs-mode: nil
# End:
