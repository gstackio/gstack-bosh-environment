#!/usr/bin/env bash

set -o pipefail

BASE_DIR=$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")
readonly BASE_DIR

# White-labeling settings
SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")
project_name=GBE
project_desc="Gstack BOSH Environment"

if ! echo "$PATH" | tr : '\n' | grep -q "^$BASE_DIR/bin$"; then
    # update PATH is not already done by direnv
    PATH=$BASE_DIR/bin:$PATH
fi

source "$BASE_DIR/lib/gbe/colors.inc.bash"
source "$BASE_DIR/lib/gbe/spec.inc.bash"
source "$BASE_DIR/lib/gbe/tunnel.inc.bash"
source "$BASE_DIR/lib/gbe/compiled-releases.inc.bash"
source "$BASE_DIR/lib/gbe/dns.inc.bash"
source "$BASE_DIR/lib/gbe/external-utilities.inc.bash"
source "$BASE_DIR/lib/gbe/hooks.inc.bash"

function pushd() {
    command pushd "$@" > /dev/null || exit 115
}

function popd() {
    command popd "$@" > /dev/null
}

function fatal() {
    echo "$@" >&2
    exit 1
}

function platform() {
    local system
    system=$(uname -s | tr '[:upper:]' '[:lower:]')
    if [[ $system == darwin || $system == linux ]]; then
        echo "$system"
    else
        fatal "${RED}ERROR:$RESET unsupported platform: '$system'. Aborting."
    fi
}

function env_usage() {
    local b=$BOLD
    local u=$UNDERLINE
    local rst=$RESET
    local bash_usage="source /dev/stdin <<< \"\$($0 env)\""
    local zsh_usage="source <\"\$(./bin/$SCRIPT_NAME env)\""
    echo
    local shell_name=$(basename "$SHELL" | tr '[:upper:]' '[:lower:]')
    case $shell_name in
        bash|sh)    usage="$b${u}$bash_usage$rst" ;;
        zsh)        usage="$b${u}$zsh_usage$rst" ;;
        *)          usage="$b${u}$zsh_usage$rst or $b${u}$bash_usage$rst" ;;
    esac
    echo "# Usage: run $usage in your $shell_name shell."
    echo
    echo "# Hint: see the actual environment variables exports" \
        "with $b${u}$SCRIPT_NAME env | cat$rst"
    echo
}

function env_exports() {
    if [[ -t 1 ]]; then
        # When running in a terminal
        env_usage
        return
    fi

    echo "export PATH=$PATH"

    local env_creds=$(state_dir "$GBE_ENVIRONMENT")/depl-creds.yml
    if [[ ! -f "$env_creds" ]]; then
        return
    fi

    function env_creds_var() {
        local path=$1
        bosh int "$env_creds" --path "$path"
    }

    env_exports_hook
    local ca_cert admin_password jumpbox_private_key env_alias depl_name
    ca_cert=$(env_creds_var /default_ca/ca)
    admin_password=$(env_creds_var /admin_password)
    jumpbox_private_key=$(state_dir "$GBE_ENVIRONMENT")/jumpbox.key
    env_alias=$(spec_var --required /infra_vars/alias "$BASE_DIR/$GBE_ENVIRONMENT")
    echo "export BOSH_CA_CERT=\"$ca_cert\""
    echo "export BOSH_CLIENT=admin"
    echo "export BOSH_CLIENT_SECRET=\"$admin_password\""
    echo "export BOSH_GW_PRIVATE_KEY=\"$jumpbox_private_key\""
    echo "export BOSH_ENVIRONMENT=\"$env_alias\""

    # We set $BOSH_DEPLOYMENT only in case no $SUBSYS_DIR is already defined
    if [[ -n $SUBSYS_DIR ]]; then
        subsys_type=$(spec_var --required /subsys/type)
        if [[ $subsys_type == bosh-deployment ]]; then
            depl_name=$(spec_var --required /deployment_vars/deployment_name)
            echo "export BOSH_DEPLOYMENT=\"$depl_name\""
        fi
    fi

    echo "export CREDHUB_SERVER=\"https://$(internal_ip):8844\""
    local credhub_ca_cert=$(state_dir "$GBE_ENVIRONMENT")/credhub_CAs.pem
    echo "export CREDHUB_CA_CERT=\"${credhub_ca_cert}\""
    {
        env_creds_var "/credhub_ca/certificate"
        env_creds_var "/default_ca/certificate"
    } > "$credhub_ca_cert"

    echo "export CREDHUB_CLIENT=\"credhub-admin\""
    echo "export CREDHUB_SECRET=\"$(env_creds_var "/credhub_admin_client_secret")\""
}

function credhub_login() {
    local creds=$(state_dir "$GBE_ENVIRONMENT")/depl-creds.yml

    if [[ ! -f "$creds" || ! -f "$(state_dir "$GBE_ENVIRONMENT")/env-infra-state.json" ]]; then
        return
    fi

    export CREDHUB_SERVER=https://$(internal_ip):8844
    export CREDHUB_CA_CERT=$(state_dir "$GBE_ENVIRONMENT")/credhub_CAs.pem
    (
        bosh int "$creds" --path /credhub_ca/certificate
        bosh int "$creds" --path /default_ca/certificate
    ) > "$CREDHUB_CA_CERT"

    export CREDHUB_CLIENT=credhub-admin
    export CREDHUB_SECRET=$(bosh int "$creds" --path /credhub_admin_client_secret)

    credhub login
}

function setup_gcp() {
    local service_account_name=$1
    local project_id=$2

    local service_account_key=$BASE_DIR/$GBE_ENVIRONMENT/conf/gcp-service-account.key.json
    if [[ -f $service_account_key ]]; then
        echo -e "INFO: the 'gcp-service-account.key.json' credentials file" \
            "already exists in directory '$BASE_DIR/$GBE_ENVIRONMENT/conf/'. ${BLUE}Skipping${RESET}."
        return 0
    fi

    assert_utilities gcloud "to setup GCP credentials"

    echo -e "${BLUE}Setting ${BOLD}GCP credentials$RESET" \
        "for service account '$service_account_name' and project '$project_id'"

    local initial_errexit=$(tr -Cd e <<< "$-")
    if [[ -z $initial_errexit ]]; then set -e; fi
    gcloud iam service-accounts create "$service_account_name"
    gcloud iam service-accounts keys create \
        --iam-account="${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        "$service_account_key"
    chmod 600 "$service_account_key"
    gcloud projects add-iam-policy-binding "$project_id" \
        --member="serviceAccount:${service_account_name}@${project_id}.iam.gserviceaccount.com" \
        --role='roles/editor'
    if [[ -z $initial_errexit ]]; then set +e; fi

    local temp_file=$(mktemp)
    sed -e "s/^  project_id:.*$/project_id: $project_id/" "$BASE_DIR/$GBE_ENVIRONMENT/conf/spec.yml" > "$temp_file"
    cp "$temp_file" "$BASE_DIR/$GBE_ENVIRONMENT/conf/spec.yml"
    rm "$temp_file"

    echo -e "$GREEN${BOLD}OK$RESET"
}

function usage() {
    echo "$project_name ($project_desc) CLI"
    echo "  $BOLD${MAGENTA}SETUP:$RESET"
    echo "  env         Sourceable envrionment variables for CLI clients"
    echo "  gcp         Configures the Google Cloud credentials"
    echo "  firewall    Configures the Google Cloud firewall rules"
    echo "  tunnel      Creates a SSH tunnel to the BOSH director, acting as a SOCKS5 proxy"
    echo
    echo "  $BOLD${MAGENTA}BOSH ENVIRONMENT:$RESET"
    echo "  up          Converges the base infrastructure environment towards its desired state"
    echo "  down        Destroys the base infrastructure environment"
    echo "  ip          Outputs the main exernal IP address of the environment"
    echo "  dns         Converge DNS towards the expected DNSControl configuration"
    echo "  ssh         Logs into the BOSH environment VM with SSH"
    echo
    echo "  $BOLD${MAGENTA}MANAGED SUBSYSTEMS:$RESET"
    echo "  update      Updates the cloud config or the runtime config"
    echo "  converge    Converges one or many subsystems towards their desired states"
    echo "  recreate    Recreates one or many subsystems towards their desired states"
    echo "  delete      Deletes one or many subsystems"
    echo
    echo "  $BOLD${MAGENTA}UTILITIES SETUP:$RESET"
    echo "  bbl         Installs locally the supported version of BOSH-Bootloader CLI"
    echo "  terraform   Installs locally the supported version of Terraform CLI"
    echo "  bosh        Installs locally the supported version of BOSH CLI"
    echo "  dnscontrol  Installs locally the supported version of DNSControl CLI"
    echo "  cf          Installs locally the supported version of Cloud Foundry CLI"
    echo
    echo "  $BOLD${MAGENTA}COMPILED RELEASES:$RESET"
    echo "  export      Popoulate the local cache with all compiled releases"
    echo "  import      Import all compiled releases from the cache to the BOSH director"
    echo "  cleanup     Delete stale compiled releases from the cache"
    echo
}

function gcp_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}gcp$noul  <service-account-name>  <project-id>"
    echo
    echo "    <service-account-name>   A name for the service account to be created"
    echo "    <project-id>             The identifier of your GCP project, like 'alpha-sandbox-717101'"
    echo
    echo "Sets the necessary GCP credentials for $project_name:"
    echo "    1. Create the designated service account in GCP."
    echo "    2. Create a service account key in 'conf/gcp-service-account.key.json'."
    echo "    3. Grant to the service account an 'editor' role on the project."
    echo
}

function up_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}up$noul  [--recreate]"
    echo
    echo "Creates or converges the BOSH environment VM with 'bosh create-env'."
    echo
    echo "Before the environment is converged, the required utilities are"
    echo "downloaded, if absent."
    echo
    echo "After the environment is converged, a SSH tunnel is started, enabling"
    echo "access the BOSH director. Then the BOSH environnment is referenced in the"
    echo "BOSH CLI config. A use of $ul$SCRIPT_NAME env$noul might be necessary though."
    echo
    echo "Any previously trusted SSH key (from the '~/.ssh/known_hosts') is replaced"
    echo "before the tunnel is started, in case it has changed, to avoid connection"
    echo "issues or hassle."
    echo
    echo "    --recreate"
    echo "        Recreate the BOSH environment base VM, even if there is no change"
    echo "        in its deployment manifest."
    echo
}

function down_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}down$noul  [-k]"
    echo
    echo "Destroys the base infrastructure environment, including the related"
    echo "BOSH director."
    echo
    echo "    -k"
    echo "        Keep some allocated resources on the automated infrastructure,"
    echo "        which is useful to preserve the allocated public IP address for"
    echo "        the BOSH director."
    echo
    echo "    -f"
    echo "        Don't run drain scripts when stopping BOSH VM micro-services"
    echo "        processes."
    echo
}

function dns_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  preview"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}dns$noul  push"
    echo
    echo "Dry-run the DNS congergence with '${b}dnscontrol preview$rst' or"
    echo "actually converge the DNS with '${b}dnscontrol push$rst'."
    echo
}

function tunnel_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  start"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  stop"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  status"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}tunnel$noul  logs"
    echo
    echo "Start or stop a SOCKS5 compatible SSH tunnel, or get its status, or"
    echo "obtain any logs produced. This tunnel is necessary in order to access"
    echo "the BOSH director, and keep it away from being exposed to the entire"
    echo "Internet, protected behind firewall rules."
    echo
    echo "Environment variables might then need to be be refreshed. Run ${ul}gbe env$noul"
    echo "for more details."
    echo
}

function update_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}update$noul  [-y]  [(cloud-config | runtime-config)...]"
    echo
    echo "Updates the cloud config or the runtime config in BOSH director."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input."
    echo
    echo "See also:"
    echo "  ${ul}https://bosh.io/docs/cloud-config.html$noul"
    echo "  ${ul}https://bosh.io/docs/runtime-config.html$noul"
    echo
}

function converge_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  [-y]  <subsys-name>..."
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  all"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}converge$noul  list"
    echo
    echo "    <subsys-name>   The name of a subsys to converge."
    echo
    echo "Converges one or all subsystems towards their desired states, or"
    echo "converge the base infrastructure environment if no subsystem is"
    echo "specified."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any"
    echo "user input. Both cloud config and runtime config will be updated,"
    echo "and all subsystems will be converged."
    echo
    echo "When specifying ${b}list$rst, the list of subsystems to converge is"
    echo "displayed, in the order ${b}gbe converge all$rst would treat them."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input."
    echo
    echo "    --manifest"
    echo "        Don't actually converge. Only render deployment manifest"
    echo "        and generate credentials. Don't run BOSH or any hooks."
    echo
    echo "    --dry-run"
    echo "        Don't actually converge. Only render deployment manifest,"
    echo "        generate credentials, and run BOSH in dry-run mode. In this"
    echo "        mode, the director downloads any necessary BOSH releases."
    echo
    echo "    --compiled"
    echo "        When converging 'all' subsystems, first upload any compiled"
    echo "        releases from the local cahe to the BOSH Director."
    echo
}

function recreate_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  [-y]  <subsys-name>..."
    echo "  $ul$SCRIPT_NAME$noul  ${ul}recreate$noul  all"
    echo
    echo "    <subsys-name>   The name of a subsys to recreate."
    echo
    echo "Recreates one or all subsystems towards their desired states."
    echo "This command is supposed to recreate subsystems that were"
    echo "previously deployed with no errors."
    echo
    echo "When specifying ${b}all$rst, the recreation will not ask for any"
    echo "user input."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input."
    echo
}

function delete_usage() {
    local b=$BOLD
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  [-y] [-f]  <subsys-name>..."
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  all [-f]"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}delete$noul  list"
    echo
    echo "    <subsys-name>   The name of a subsys to delete."
    echo
    echo "Deletes one or all subsystems. This ${b}delete$rst operation is"
    echo "VERY DESTRUCTIVE."
    echo
    echo "When destroying ${b}all$rst subsystems, the deletion will not ask"
    echo "for any user input."
    echo
    echo "When specifying ${b}list$rst, the list of subsystems to delete is"
    echo "displayed, in the order ${b}gbe delete all$rst would treat them."
    echo
    echo "    -y"
    echo "        Run unattended. Don't ask for user input. NOT RECOMMENDED."
    echo
    echo "    -f"
    echo "        Ignore errors. SHOULD BE USED WITH CAUTION, as a last resort"
    echo "        only."
    echo
}

function export_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}export$noul  [<subsys-name>]"
    echo
    echo "    <subsys-name>   The name of a subsys of type 'bosh-deployment'."
    echo
    echo "Exports all compiled releases from the BOSH Director, going through"
    echo "all deployments currently managed by the BOSH director, as described"
    echo "by all subsystems."
    echo
    echo "When specifying a subsys name, the set of exported releases is"
    echo "restricted to those related to the specified subsystem. This"
    echo "subsystem must be of type 'bosh-deployment' and the related"
    echo "BOSH deployment must exist in the BOSH director."
    echo
}

function import_usage() {
    local ul=$UNDERLINE
    local noul=$NOUNDERLINE
    local rst=$RESET
    echo "Usage:"
    echo "  $ul$SCRIPT_NAME$noul  ${ul}import$noul  [<subsys-name>]"
    echo
    echo "    <subsys-name>   The name of a subsys of type 'bosh-deployment'."
    echo
    echo "Imports all compiled releases going through each deployments currently"
    echo "managed by the BOSH director, as described by all subsystems."
    echo
    echo "When specifying a subsys name, the exported BOSH releases are those"
    echo "that are necessary to the BOSH deployment that the subsys describes."
    echo "This subsys must be of type 'bosh-deployment' and there must be a"
    echo "subfolder of that name in the '.cache/compiled-releases/' directory."
    echo
}

function setup_firewall() {
    setup_firewall_hook
}

function ensure_reachability() {
    ensure_reachability_hook
}

function add_routes() {
    local network_cidr platform netstat_pattern sudo_cmd
    network_cidr=$(spec_var /deployment_vars/routable_network_cidr "$BASE_DIR/$GBE_ENVIRONMENT" | sed -e 's/^null$//')
    if [[ -z $network_cidr ]]; then
        return
    fi

    local vbox_host ssh_cmd sudo_host_type
    vbox_host=$(env_depl_var vbox_host | sed -e 's/^null$//')
    if [[ -n $vbox_host ]]; then
        local vbox_username
        vbox_username=$(env_depl_var --required vbox_username)
        ssh_cmd=(ssh -t "${vbox_username}@${vbox_host}")
        sudo_host_type=remote
    else
        sudo_host_type=local
    fi

    function sed_cmd() {
        case $(platform) in
            darwin) sed -E "$@" ;;
            linux)  sed -r "$@" ;;
        esac
    }

    platform=$("${ssh_cmd[@]}" uname -s | tr '[:upper:]' '[:lower:]' | tr -d '\r\n')
    case $platform in
        darwin) netstat_pattern=$(sed_cmd -e 's`(\.0)+(/[0-9]+)?$`\2`' <<< "$network_cidr") ;;
        linux)  netstat_pattern=$(sed_cmd -e 's`/[0-9]+$``' <<< "$network_cidr") ;;
    esac
    if "${ssh_cmd[@]}" netstat -nr | awk '{print $1}' | grep -qE "^${netstat_pattern//./\\.}\$"; then
        return
    fi

    echo -e "\n${BLUE}Adding ${BOLD}route$RESET to reach the BOSH director and deployed nodes\n"
    sudo_cmd=(sudo --prompt="'[${MAGENTA}${UNDERLINE}${sudo_host_type}${NOUNDERLINE} ${BOLD}sudo$RESET (on %h)] password for %u: '")
    case $platform in
        darwin) "${ssh_cmd[@]}" "${sudo_cmd[@]}" route add -net "$network_cidr"    "$(internal_ip)" ;;
        linux)  "${ssh_cmd[@]}" "${sudo_cmd[@]}" route add -net "$network_cidr" gw "$(internal_ip)" ;;
        *)
            echo "${RED}ERROR:$RESET cannot set routes on unsupported platform '$platform'" >&2
            exit 1 ;;
    esac
}

function update_config() {
    local cfg_type=$1; shift # 'cloud' or 'runtime'

    SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT/${cfg_type}-config
    eval "$(env_exports)"

    # Assert subsystem is a BOSH config
    # (meaning: cloud config or runtime config)
    assert_subsys bosh-config

    set -e

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    local subsys_state_dir subsys_type
    subsys_state_dir=$(state_dir)
    mkdir -p "$subsys_state_dir"
    subsys_type=$(spec_var --required /subsys/type)
    "read_${subsys_type}_spec"


    echo -e "\n${BLUE}Updating $BOLD$cfg_type config$RESET in BOSH director.\n"

    bosh interpolate "$MAIN_CONFIG_FILE" \
        "${OPERATIONS_ARGUMENTS[@]}" \
        --vars-file <(spec_var /config_vars) \
        --vars-file <(imported_vars) \
        > "$subsys_state_dir/${cfg_type}-config.yml"
    [[ -x $(which humanize-manifest) ]] && \
        humanize-manifest "$subsys_state_dir/${cfg_type}-config.yml" \
            > "$subsys_state_dir/${cfg_type}-config-humanized.yml" \
            || true

    if [[ ! -s $subsys_state_dir/${cfg_type}-config.yml ]]; then
        echo "${cfg_type} config file is empty." \
                "${BLUE}Skipping$RESET update." \
            | awk '{print toupper(substr($0,1,1)) substr($0,2)}'
        exit 0
    fi
    bosh update-${cfg_type}-config "$subsys_state_dir/${cfg_type}-config.yml" "$@"
}

function upload_stemcell() {
    local stemcell_name stemcell_version stemcell_sha1

    stemcell_name=$(spec_var /deployment_vars/stemcell_name)
    stemcell_version=$(spec_var /deployment_vars/stemcell_version)
    stemcell_sha1=$(spec_var /deployment_vars/stemcell_sha1)

    if [[ -z $stemcell_name || -z $stemcell_version || -z $stemcell_sha1 ]]; then
        return
    fi

    bosh upload-stemcell \
        --name "$stemcell_name" \
        --version "$stemcell_version" \
        --sha1 "$stemcell_sha1" \
        "https://bosh.io/d/stemcells/$stemcell_name?v=$stemcell_version"
}

function list_subsystems() {
    echo -e "\n$BLUE${BOLD}Affected subsystems$RESET in order:\n"
    each_subsystem "$@" print_subsys_name
    echo
}

function print_subsys_name() {
    local subsys_name=$1; shift
    echo "  - $subsys_name" "$@"
}

function max_of() {
    local a=$1 b=$2
    echo $(( $a > $b ? $a : $b ))
}

function dependency_type() {
    local for_subsys_dir=$1
    local subsys_name=$2
    local base_path=$3

    local vars_count var_idx var_path import_from dep_level

    dep_level=0
    vars_count=$(spec_var "${base_path}" "${for_subsys_dir}" \
                        | awk '/^-/{print $1}' | wc -l | tr -d " ")
    var_idx=0
    while [[ ${var_idx} -lt ${vars_count} ]]; do
        var_path="${base_path}/${var_idx}"
        import_from=$(spec_var --required "${var_path}/from" "$for_subsys_dir")
        case $import_from in
            depl-vars|conf-vars)
                dep_level=$(max_of 0 "${dep_level}") ;;
            vars-file|depl-manifest|depl-creds)
                # NOTE: depending on whether 'vars-file' refers to a file in
                # the project repo or in a 'input resource' repo, the
                # dependency level is 0 or 1 (respectively).
                #
                # For simplicity of the code here, we assume the higher level
                # of dependency of 1 for 'vars-file' dependencies.
                dep_level=$(max_of 1 "${dep_level}") ;;
            bbl-vars)
                dep_level=$(max_of 2 "${dep_level}") ;;
            *)
                echo "${RED}ERROR:${RESET} while computing dependency type," \
                    "unsupported var import type: '${import_from}'." \
                    "Expected 'bbl-vars', 'vars-file', 'depl-vars', 'conf-vars'," \
                    "'depl-manifest' or 'depl-creds'. Aborting." >&2
                return 1 ;;
        esac

        var_idx=$(($var_idx + 1))
    done

    if [[ $dep_level -ge 2 ]]; then
        echo "${subsys_name}"
    elif [[ $dep_level -eq 1 ]]; then
        echo "${subsys_name}-manifest"
    fi
}

function generate_dependencies() {
    local for_subsys_dir=$1
    local with_subsys_name=$2

    local subsys_count idx subsys_path subsys_name
    subsys_count=$(spec_var /imported_vars "$for_subsys_dir" \
                    | awk '/^-/{print $1}' | wc -l | tr -d ' ')
    idx=0
    while [[ $idx -lt $subsys_count ]]; do
        subsys_path=/imported_vars/$idx
        idx=$(($idx + 1))
        subsys_name=$(spec_var --required "$subsys_path/subsys" "$for_subsys_dir")
        if [[ $subsys_name == *-env ]]; then
            # Let's assume that environments are properly converged
            continue
        fi
        if [[ $subsys_name == $with_subsys_name ]]; then
            # Ignore any self-dependencies
            continue
        fi
        dependency_type "$for_subsys_dir" "$subsys_name" "$subsys_path/imports"
    done
}

function generate_makefile() {
    local old_IFS subsys_dirs
    old_IFS=$IFS
    IFS=$'\n'
    subsys_dirs=($(find "$BASE_DIR/deployments" -mindepth 1 -maxdepth 1 \
            -type d \! -name 'zzz-*' \
            -print))
    IFS=$old_IFS

    local subsys_dir subsys_basenames
    for subsys_dir in "${subsys_dirs[@]}"; do
        subsys_basenames+=($(basename "$subsys_dir"))
    done

    echo -e "\nVERB?=converge\n"
    echo -e "all: ${GBE_ENVIRONMENT} cloud-config runtime-config ${subsys_basenames[*]}\n"

    echo -e "${GBE_ENVIRONMENT}:"
    echo -e "\tgbe up\n"

    local cfg_type
    for cfg_type in cloud runtime; do
        echo -e "${cfg_type}-config:"
        echo -e "\tgbe update -y \$@\n"
    done

    local subsys_basename subsys_name \
            auto_deps declarated_deps merged_deps dedup_deps dep
    for subsys_dir in "${subsys_dirs[@]}"; do
        subsys_basename=$(basename "$subsys_dir")
        subsys_name=$(spec_var --required /subsys/name "$subsys_dir")
        if [[ $subsys_basename != $subsys_name ]]; then
            echo "${RED}ERROR:${RESET} subsys name mismatch." \
                "Expected 'subsys.name: $subsys_basename' YAML node" \
                "in '$subsys_basename/conf/spec.yml' file," \
                "but found '$subsys_name'. Aborting." >&2
            return 1
        fi

        auto_deps=$(generate_dependencies "$subsys_dir" "$subsys_name")
        declarated_deps=$(spec_var /subsys/depends_on "$subsys_dir" \
                | sed -ne 's/^- //p')

        merged_deps=$(sort --merge <(sort <<< "$auto_deps") <(sort <<< "$declarated_deps"))

        dedup_deps="${merged_deps//$'\n'/ }"
        for dep in ${declarated_deps}; do
            dedup_deps=$(sed -e "s/${dep} ${dep}-manifest/${dep}/" <<< "$dedup_deps")
        done

        echo -e "${subsys_basename}-manifest: ${auto_deps//$'\n'/ }"
        echo -e "\tgbe converge --manifest \$@\n"

        echo -e "${subsys_basename}: ${dedup_deps}"
        echo -e "\tgbe \$(VERB) -y \$@\n"
    done
}

function generate_depl_order_makefile() {
    local old_IFS subsys_dirs
    old_IFS=$IFS
    IFS=$'\n'
    subsys_dirs=($(find "$BASE_DIR/deployments" -mindepth 1 -maxdepth 1 \
            -type d \! -name 'zzz-*' \
            -print))
    IFS=$old_IFS

    local subsys_dir subsys_basenames
    for subsys_dir in "${subsys_dirs[@]}"; do
        subsys_basenames+=($(basename "$subsys_dir"))
    done

    echo -e "all: ${subsys_basenames[*]}\n"

    local subsys_basename subsys_name \
            auto_deps declarated_deps merged_deps dedup_deps dep
    for subsys_dir in "${subsys_dirs[@]}"; do
        subsys_basename=$(basename "$subsys_dir")
        subsys_name=$(spec_var --required /subsys/name "$subsys_dir")
        if [[ $subsys_basename != $subsys_name ]]; then
            echo "${RED}ERROR:${RESET} subsys name mismatch." \
                "Expected 'subsys.name: $subsys_basename' YAML node" \
                "in '$subsys_basename/conf/spec.yml' file," \
                "but found '$subsys_name'. Aborting." >&2
            return 1
        fi

        auto_deps=$(generate_dependencies "$subsys_dir" "$subsys_name")
        declarated_deps=$(spec_var /subsys/depends_on "$subsys_dir" \
                | sed -ne 's/^- //p')

        merged_deps=$(sort --merge <(sort <<< "$auto_deps") <(sort <<< "$declarated_deps"))

        dedup_deps="${merged_deps//$'\n'/ }"
        for dep in ${declarated_deps}; do
            dedup_deps=$(sed -e "s/${dep} ${dep}-manifest/${dep}/" <<< "$dedup_deps")
        done

        echo -e "${subsys_basename}-manifest: ${auto_deps//$'\n'/ }"
        echo -e "\t\$@\n"

        echo -e "${subsys_basename}: ${dedup_deps}"
        echo -e "\t\$@\n"
    done
}

function each_subsystem() {
    local reverse_arg cmd
    if [[ x$1 == x-r || x$1 == x--reverse ]]; then
        reverse_arg=$1; shift
    fi
    cmd=$1; shift

    assert_utilities make "to compute subsys ordering given their dependencies"

    local makefile
    makefile=$(state_dir "$GBE_ENVIRONMENT")/ordering.makefile
    generate_depl_order_makefile > $makefile

    local old_IFS=$IFS
    IFS=$'\n'
        local subsystems
        subsystems=$(make -f "${makefile}" -n all | cat -n | sed -e 's/^ *//')
        if [[ -n $reverse_arg ]]; then
            subsystems=$(grep -v ' --manifest$' <<< "${subsystems}")
        fi
        subsystems=($(sort -n $reverse_arg -s -k 1,2 <<< "${subsystems}" | cut -d $'\t' -f2-))

        local subsys_name
        for subsys_name in "${subsystems[@]}"; do
            if [[ "${subsys_name}" == *"-manifest" ]]; then
                "${cmd}" "${subsys_name%"-manifest"}" --manifest "$@"
            else
                "${cmd}" "${subsys_name}" "$@"
            fi
        done
    IFS=$old_IFS
}

function assert_subsys_name() {
    local subsys=$1
    if [[ ! -d $BASE_DIR/deployments/$subsys ]]; then
        echo "${RED}ERROR:$RESET no such $project_name subsys: '$subsys'."
        return 1
    fi
    return 0
}

function converge_subsystem() {
    local subsys_name=$1; shift

    local manifest_only dry_run offline
    if [[ $@ == *--manifest* ]]; then manifest_only=yes; fi
    if [[ $@ == *--dry-run* ]]; then  dry_run=yes; fi
    if [[ $@ == *--offline* ]]; then  offline=yes; fi

    local action="Converging"
    if [[ -n $manifest_only ]]; then
        action="Rendering deployment manifest and generating credentials for"
    elif [[ -n $dry_run ]]; then
        action="Converging (dry run)"
    fi

    echo -e "\n${BLUE}$action the $BOLD'$subsys_name'$RESET subsystem.\n"

    SUBSYS_DIR=$BASE_DIR/deployments/$subsys_name
    eval "$(env_exports)"
    if [[ -z $manifest_only && -z $offline ]]; then
        upload_stemcell
    fi

    assert_subsys bosh-deployment

    set -e

    UPSTREAM_RESOURCES=()
    fetch_input_resources ${offline:+"--offline"}

    local subsys_state_dir
    subsys_state_dir=$(state_dir)
    mkdir -p "$subsys_state_dir"

    local upstream_subsys
    upstream_subsys=$(spec_var /subsys/upstream)
    if [[ -n $upstream_subsys && ${#UPSTREAM_RESOURCES[@]} -ge 1 ]]; then
        assert_utilities spruce "to create the merged subsys spec file"

        local upstream_dir upstream_spec overriding_spec
        upstream_dir=$(expand_resource_dir "$upstream_subsys")
        upstream_spec=$upstream_dir/conf/spec.yml
        overriding_spec=$SUBSYS_DIR/conf/spec.yml
        SPEC_FILE=$subsys_state_dir/merged-spec.yml
        spruce merge --prune ".subsys.upstream" \
            "$upstream_spec" "$overriding_spec" > "$SPEC_FILE"

        # Fetch any new resources from the merged spec
        fetch_input_resources ${offline:+"--offline"}
    fi

    local subsys_type
    subsys_type=$(spec_var --required /subsys/type)
    "read_${subsys_type}_spec" "$@"

    restrict_permissions "$subsys_state_dir/depl-creds.yml"
    bosh_ro_invoke interpolate > "$subsys_state_dir/depl-manifest.yml"
    [[ -x $(which humanize-manifest) ]] && \
        humanize-manifest "$subsys_state_dir/depl-manifest.yml" \
            > "$subsys_state_dir/depl-manifest-humanized.yml" \
            || true

    if [[ -n $manifest_only || -n $offline ]]; then
        bosh_rw_invoke interpolate > /dev/null # generate credentails if necessary
        echo -e "\nBOSH deployment manifest is rendered (and credentials" \
            "generated) in '${subsys_state_dir/#$PWD\//}' directory.\n"
        return
    fi

    if [[ -z $dry_run ]]; then
        run_hook_once pre-deploy "$SUBSYS_DIR/pre-deploy-once.sh"
        run_hook "$SUBSYS_DIR/pre-deploy.sh"
    fi

    if [[ ${GBE_DEBUG_LEVEL} -ge 2 ]]; then
        set -- "$@" --no-redact
    fi
    bosh_rw_invoke deploy "$@"

    if [[ -z $dry_run ]]; then
        run_hook_once post-deploy "$SUBSYS_DIR/post-deploy-once.sh"
        run_hook "$SUBSYS_DIR/post-deploy.sh"
    fi
}

function delete_subsystem() {
    local subsys_name=$1; shift

    local ignore_errors=no
    if [[ $@ == *--force* ]]; then ignore_errors=yes; fi

    echo -e "\n${BLUE}Deleting the $BOLD'$subsys_name'$RESET subsystem.\n"

    SUBSYS_DIR=$BASE_DIR/deployments/$subsys_name
    eval "$(env_exports)"

    assert_subsys bosh-deployment

    run_hook "$SUBSYS_DIR/pre-delete.sh"
    local hook_error=$?

    if [[ $ignore_errors == no && $hook_error -ne 0 ]]; then
        return $hook_error
    fi

    bosh delete-deployment "$@"

    rm -f "$(state_dir)"/{pre,post}-deploy-hook.yml
}

function restrict_permissions() {
    local filename=$1

    >> "$filename"
    chmod 600 "$filename"
}

function internal_ip() {
    internal_ip_hook
}

function external_ip() {
    external_ip_hook
}

function gbe_up() {
    setup_bbl
    setup_terraform
    setup_bosh_cli
    setup_spruce
    setup_dnscontrol
    setup_cf_cli

    assert_utilities ruby "to render ERB templates locally"

    SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT
    create_env "$@"

    if [[ -f ~/.ssh/known_hosts ]]; then
        ssh-keygen -f ~/.ssh/known_hosts -R "$(jumpbox_ip)"
    fi
    ssh-keyscan -t ecdsa "$(jumpbox_ip)" 2> /dev/null \
        >> ~/.ssh/known_hosts

    # This workaround avoids the "Too many authentication failures for
    # jumpbox" error when ensuring reachability below.
    ssh-add -D || true # might fail when no authentication agent is running

    ensure_reachability
    setup_firewall

    if [[ -n $(spec_var /deployment_vars/director_name | sed -e 's/^null$//') ]]; then
        alias_env
    fi
}

function alias_env() {
    eval "$(env_exports)"
    echo -e "\n${BLUE}Aliasing the created BOSH environment to ${BOLD}'$BOSH_ENVIRONMENT'$RESET\n"

    bosh -e "$(internal_ip)" alias-env "$BOSH_ENVIRONMENT"
}

function create_env() {

    # Assert subsystem is a bosh-environment
    assert_subsys bosh-environment

    set -e

    echo -e "\n${BLUE}Converging$RESET the '${BOLD}${GBE_ENVIRONMENT}${RESET}' environment\n"

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    local env_state_dir subsys_type
    env_state_dir=$(state_dir "$GBE_ENVIRONMENT")
    mkdir -p "$env_state_dir"
    subsys_type=$(spec_var --required /subsys/type)
    "read_${subsys_type}_spec"


    pre_create_env_hook


    if ! has_dns_enabled; then
        echo -e "\n${BLUE}Skipping ${BOLD}dnscontrol push$RESET, as the '$DNS_CREDS_FILE' file is absent\n"
    else
        echo -e "\n${BLUE}Running ${BOLD}dnscontrol push$RESET to converge the external DNS zone\n"
        push_dns_config
    fi


    echo -e "\n${BLUE}Running ${BOLD}bosh create-env$RESET to create the BOSH environment\n"

    infra_bosh_ro_invoke interpolate > "$env_state_dir/depl-manifest.yml"
    [[ -x $(which humanize-manifest) ]] && \
        humanize-manifest "$env_state_dir/depl-manifest.yml" \
            > "$env_state_dir/depl-manifest-humanized.yml" \
            || true

    if [[ ${GBE_DEBUG_LEVEL} -ge 3 ]]; then
        # This is just an example of how we can have verbose logs using the
        # GBE_DEBUG_LEVEL environment variable.
        export BOSH_LOG_LEVEL="DEBUG"
        export BOSH_LOG_PATH="${env_state_dir}/bosh-create-env.log"
    fi
    infra_bosh_rw_invoke create-env "$@"


    post_create_env_hook
}

function delete_env() {
    local ignore_errors=no
    if [[ $@ == *--force* ]]; then ignore_errors=yes; fi

    SUBSYS_DIR=$BASE_DIR/$GBE_ENVIRONMENT

    # Assert subsystem is a bosh-environment
    assert_subsys bosh-environment

    set -e

    echo -e "\n${BLUE}Deleting$RESET the '${BOLD}${GBE_ENVIRONMENT}${RESET}' environment\n"

    echo -e "\n${BLUE}Fetching ${BOLD}input resources$RESET\n"

    fetch_input_resources
    local subsys_state_dir subsys_type
    subsys_state_dir=$(state_dir "$GBE_ENVIRONMENT")
    mkdir -p "$subsys_state_dir"
    subsys_type=$(spec_var --required /subsys/type)
    "read_${subsys_type}_spec"


    pre_delete_env_hook


    restrict_permissions "$subsys_state_dir/depl-creds.yml"
    infra_bosh_ro_invoke interpolate > "$subsys_state_dir/depl-manifest.yml"
    [[ -x $(which humanize-manifest) ]] && \
        humanize-manifest "$subsys_state_dir/depl-manifest.yml" \
            > "$subsys_state_dir/depl-manifest-humanized.yml" \
            || true

    echo -e "\n${BLUE}Logging out from credhub and closing SSH tunnel$RESET\n"

    if which credhub > /dev/null; then
        credhub logout
    fi
    cease_reachability_hook


    if [[ ! -e $subsys_state_dir/env-infra-state.json ]]; then
        echo -e "\n${BLUE}Skipping ${BOLD}bosh delete-env$RESET, as the 'state/$GBE_ENVIRONMENT/env-infra-state.json' file is absent\n"
    else
        echo -e "\n${BLUE}Running ${BOLD}bosh delete-env$RESET to destroy the BOSH environment\n"
        infra_bosh_rw_invoke delete-env ${ignore_errors:+"--skip-drain"}
        # rm -vf "$subsys_state_dir/depl-creds.yml"
    fi

    rm -f "$BASE_DIR"/state/*/{pre,post}-deploy-hook.yml

    if [[ ! -e $subsys_state_dir/jumpbox.key ]]; then
        echo -e "\n${BLUE}Skipping ${BOLD}SSH key removal$RESET, as it is absent\n"
    else
        echo -e "\n${BLUE}Removing ${BOLD}SSH key$RESET from SSH Agent\n"
        ssh-keygen -y -f "$subsys_state_dir/jumpbox.key" > "$subsys_state_dir/jumpbox.key.pub"
        if ssh-add -L | grep -qF "$( < "$subsys_state_dir/jumpbox.key.pub" )"; then
            ssh-add -d "$subsys_state_dir/jumpbox.key.pub"
        fi
        rm -vf "$subsys_state_dir/jumpbox.key" "$subsys_state_dir/jumpbox.key.pub"
        ssh-keygen -f ~/.ssh/known_hosts -R "$(jumpbox_ip)"
    fi


    post_delete_env_hook
}

# GBE_ENVIRONMENT=${GBE_ENVIRONMENT:-gcp-env}
GBE_ENVIRONMENT=${GBE_ENVIRONMENT:-ddbox-env}

function load_env_flavor_hooks() {
    setup_bosh_cli >&2

    local gbe_env_flavor
    gbe_env_flavor=$(spec_var --required /infra_vars/iaas "$BASE_DIR/$GBE_ENVIRONMENT")

    source "$BASE_DIR/lib/envs-flavors/$gbe_env_flavor/infra-hooks.inc.bash"
}
load_env_flavor_hooks

case $1 in
    env)        env_exports ;;
    bbl)        setup_bbl ;;
    terraform)  setup_terraform ;;
    bosh)       setup_bosh_cli ;;
    spruce)     setup_spruce ;;
    dnscontrol) setup_dnscontrol ;;
    credhub)
        setup_credhub_cli
        ensure_reachability
        credhub_login
        ;;
    cf)         setup_cf_cli ;;
    gcp)
        shift
        if [[ $1 == "-h" ]]; then
            gcp_usage; exit 0
        elif [[ $# -ne 2 ]]; then
            gcp_usage; exit 2
        fi
        setup_gcp "$@"
        ;;
    up)
        shift
        do_recreate=
        while [[ -n $1 ]]; do
            case $1 in
                -h)         up_usage; exit 0 ;;
                --recreate) do_recreate=yes ;;
                *)          up_usage; exit 2 ;;
            esac
            shift
        done
        gbe_up ${do_recreate:+"--recreate"}
        ;;
    alias)
        alias_env ;;
    ip)
        jumpbox_ip | cat ;;
    bosh-installation)
        assert_utilities jq "to display the BOSH installation path"
        installation_id=$(jq -r .installation_id "state/$GBE_ENVIRONMENT/env-infra-state.json")
        echo "$HOME/.bosh/installations/$installation_id"
        ;;
    down)
        shift
        ignore_errors=
        while [[ -n $1 ]]; do
            case $1 in
                -h) down_usage; exit 0 ;;
                -f) ignore_errors=yes ;;
                *)  down_usage; exit 2 ;;
            esac
            shift
        done
        delete_env ${ignore_errors:+"--force"}
        ;;
    firewall)   setup_firewall ;;
    tunnel)
        shift
        case $1 in
            start)  start_tunnel  ;;
            stop)   stop_tunnel   ;;
            status) tunnel_status ;;
            logs)   tunnel_logs   ;;
            -h)     tunnel_usage; exit 0 ;;
            *)      tunnel_usage; exit 2 ;;
        esac
        ;;
    routes)
        add_routes ;;
    dns)
        shift
        verb=$1
        case $verb in
            preview)    preview_dns_config ;;
            push)       push_dns_config ;;
            -h)         dns_usage; exit 0 ;;
            *)          dns_usage; exit 2 ;;
        esac
        ;;
    ssh)
        shift
        ssh_jumpbox "$@"
        ;;
    makefile)
        generate_makefile > $(state_dir "$GBE_ENVIRONMENT")/Makefile
        ;;
    update)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                -y)
                    non_interactive=yes ;;
                cloud-config)
                    ensure_reachability
                    update_config cloud ${non_interactive:+"-n"}
                    ;;
                runtime-config)
                    ensure_reachability
                    update_config runtime ${non_interactive:+"-n"}
                    ;;
                -h) update_usage; exit 0 ;;
                *)  update_usage; exit 2 ;;
            esac
            shift
        done
        ;;
    converge)
        shift
        if [[ -z $1 ]]; then
            gbe_up
        else
            non_interactive=
            manifest_only=
            dry_run=
            offline=
            compiled=
            while [[ -n $1 ]]; do
                case $1 in
                    -h)         converge_usage; exit 0 ;;
                    -y)         non_interactive=yes ;;
                    --manifest) manifest_only=yes ;;
                    --dry-run)  dry_run=yes ;;
                    --offline)  offline=yes ;;
                    --compiled) compiled=yes ;;
                    list)
                        list_subsystems
                        break ;;
                    all)
                        ensure_reachability
                        if [[ $compiled == "yes" ]]; then
                            upload_compiled_releases
                        fi
                        update_config cloud -n
                        update_config runtime -n
                        list_subsystems
                        each_subsystem converge_subsystem -n
                        break ;;
                    *)
                        if ! assert_subsys_name "$1"; then
                            converge_usage; exit 2
                        fi
                        ensure_reachability
                        converge_subsystem "$1" \
                            ${non_interactive:+"-n"} \
                            ${manifest_only:+"--manifest"} \
                            ${dry_run:+"--dry-run"} \
                            ${offline:+"--offline"} ;;
                esac
                shift
            done
        fi
        ;;
    recreate)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                -h) recreate_usage; exit 0 ;;
                -y) non_interactive=yes ;;
                all)
                    ensure_reachability
                    list_subsystems
                    each_subsystem converge_subsystem -n --recreate --fix --canaries=0
                    break ;;
                *)
                    if ! assert_subsys_name "$1"; then
                        recreate_usage; exit 2
                    fi
                    converge_subsystem "$1" ${non_interactive:+"-n"} --recreate --fix --canaries=0 ;;
            esac
            shift
        done
        ;;
    recover)
        shift
        non_interactive=
        while [[ -n $1 ]]; do
            case $1 in
                -h) recover_usage; exit 0 ;;
                -y) non_interactive=yes ;;
                *)
                    if ! assert_subsys_name "$1"; then
                        recover_usage; exit 2
                    fi
                    subsys_name=$1
                    subsys_dir=$(get_subsys_dir_from_subsys_name "${subsys_name}")
                    deployment_name=$(spec_var --required "/deployment_vars/deployment_name" "${subsys_dir}")
                    bosh cloud-check -d "${deployment_name}" ${non_interactive:+-n --auto --resolution=recreate_vm} ;;
            esac
            shift
        done
        ;;
    delete)
        shift
        non_interactive=
        ignore_errors=
        while [[ -n $1 ]]; do
            case $1 in
                -h) delete_usage; exit 0 ;;
                -y) non_interactive=yes ;;
                -f) ignore_errors=yes ;;
                list)
                    list_subsystems --reverse
                    break ;;
                all)
                    shift
                    ensure_reachability
                    list_subsystems --reverse
                    each_subsystem --reverse delete_subsystem -n ${ignore_errors:+"--force"} "$@"
                    break ;;
                *)
                    if ! assert_subsys_name "$1"; then
                        delete_usage; exit 2
                    fi
                    ensure_reachability
                    delete_subsystem "$1" ${non_interactive:+"-n"} ${ignore_errors:+"--force"} ;;
            esac
            shift
        done
        ;;
    export)
        shift
        case $1 in
            -h) export_usage; exit 0 ;;
            *)
                ensure_reachability
                export_releases "$@" ;;
        esac
        ;;
    import)
        shift
        case $1 in
            -h) import_usage; exit 0 ;;
            *)
                ensure_reachability
                upload_compiled_releases "$@" ;;
        esac
        ;;
    cleanup)
        shift
        cleanup_compiled_releases "$@";;
    -h) usage; exit 0 ;;
    *)  usage; exit 2 ;;
esac

# Local Variables:
# indent-tabs-mode: nil
# End:
